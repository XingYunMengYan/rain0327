<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å››è·¯çº¿å¡ç‰Œå¯¹æˆ˜ â€” é¢å¯¹é¢æ¨¡å¼</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

    <!-- å…±äº«å·¥å…·åº“ï¼ˆçº¯JSï¼Œæ— JSXï¼‰ -->
    <script src="shared.js"></script>
    <script src="cardEffects.js"></script>
</head>
<body>
    <!-- ä½œå¼ŠUI -->
    <div id="cheat-ui" style="position:fixed; top:10px; right:10px; z-index:10000; background:rgba(0,0,0,0.6); padding:8px; border-radius:8px; display:flex; gap:5px;">
        <input type="number" id="cheat-card-id" placeholder="å¡ç‰ŒID" 
               style="width:70px; padding:4px; border-radius:4px; border:none; outline:none; font-size:12px;">
        <button onclick="window.spawnCheatCard()" 
                style="background:#f59e0b; color:white; padding:4px 8px; border-radius:4px; font-weight:bold; font-size:12px; border:none; cursor:pointer;">
            åˆ·ç‰Œ
        </button>
    </div>
    
    <!-- Reactæ ¹èŠ‚ç‚¹ -->
    <div id="root"></div>

    <script type="text/babel">
    // ============================================================
    // localGame â€” é¢å¯¹é¢æ¨¡å¼é€»è¾‘å±‚
    // UI å…¨éƒ¨ç”± GameUI ç»„ä»¶è´Ÿè´£ï¼Œæ­¤å¤„åªå†™ state + è§„åˆ™
    // ============================================================
    const { useState, useEffect, useCallback } = React;

    const LocalGame = () => {
      // â”€â”€ ç­‰å¾… GameUI åŠ è½½å®Œæˆ â”€â”€
      const [uiReady, setUiReady] = useState(false);

      useEffect(() => {
        window.GameUILoader.load().then(() => setUiReady(true));
        // æ¢å¤éŸ³æ•ˆè®¾ç½®
        window.SoundManager.restoreFromStorage();
      }, []);

      // â”€â”€ å¡ç‰Œæ•°æ® â”€â”€
      const [allCards, setAllCards] = useState([]);

      useEffect(() => {
        window.loadCards()
          .then(cards => setAllCards(cards))
          .catch(err => {
            console.error('åŠ è½½å¡ç‰Œå¤±è´¥', err);
            alert('æ— æ³•åŠ è½½ card_data.csvï¼Œè¯·ç¡®ä¿æ–‡ä»¶åœ¨åŒä¸€ç›®å½•ä¸‹å¹¶é€šè¿‡æœ¬åœ°æœåŠ¡å™¨è®¿é—®ã€‚');
          });
      }, []);

      // â”€â”€ æ¸¸æˆæ ¸å¿ƒçŠ¶æ€ â”€â”€
      const INIT_STATE = {
        turn: 0,
        phase: 'idle',   // idle | redDeploy | blueDeploy | redSupport | battle
        red:  { health: 30, coins: 0, hand: [], battlefield: [null,null,null,null], buildings: [null,null,null,null], miracleDrawn: [30] },
        blue: { health: 30, coins: 0, hand: [], battlefield: [null,null,null,null], buildings: [null,null,null,null], miracleDrawn: [30] },
        deck: [],
        miracleDeck: [],
        discardPile: [],
        initialCards: [],        // å½“å‰é€‰ç‰Œé˜¶æ®µå¾…é€‰çš„6å¼ 
        initialCardsBlue: [],    // è“æ–¹å¾…é€‰çš„6å¼ ï¼ˆçº¢æ–¹é€‰å®Œåæ›¿æ¢ï¼‰
        selectedCard: null,
        log: []
      };

      const [gameState,       setGameState]      = useState(INIT_STATE);
      const [gamePhase,       setGamePhase]      = useState('notStarted');
      const [winner,          setWinner]         = useState(null);
      const [battleAnimation, setBattleAnimation] = useState({ active: false, lane: -1 });
      const [cardShowOverlay, setCardShowOverlay] = useState(null);  // æ”¯æ´/å¥‡è¿¹å±•ç¤º
      const [swapMode,        setSwapMode]       = useState(null);   // äº¤æ¢æ¨¡å¼: { type: 'reposition'/'swapBattlefield', card, firstSlot: {player, lane} }

      // â”€â”€ æ—¥å¿—è¾…åŠ© â”€â”€
      const addLog = useCallback((msg) => {
        setGameState(prev => ({ ...prev, log: [...prev.log, msg] }));
      }, []);

      // â”€â”€ è¢«åŠ¨æ•ˆæœè®¡ç®—ç³»ç»Ÿï¼ˆæ‰©å±•ç‰ˆï¼‰ â”€â”€
      const calculatePassiveEffects = useCallback((state) => {
        // æ·±æ‹·è´çŠ¶æ€é¿å…ç›´æ¥ä¿®æ”¹
        const newState = JSON.parse(JSON.stringify(state));
        
        console.log('[calculatePassiveEffects] å¼€å§‹è®¡ç®—è¢«åŠ¨æ•ˆæœ');
        
        // è¾…åŠ©å‡½æ•°ï¼šç»Ÿè®¡ç‰¹å®šç§æ—æ•°é‡
        const countRaces = (player, races) => {
          let count = 0;
          newState[player].battlefield.forEach(c => {
            if (c && races.some(r => c.stRace === r || c.ndRace === r)) {
              count++;
            }
          });
          return count;
        };

        // è¾…åŠ©å‡½æ•°ï¼šç»Ÿè®¡å…¨åœºç‰¹å®šç§æ—æ•°é‡
        const countAllRaces = (races) => {
          let count = 0;
          ['red', 'blue'].forEach(p => {
            newState[p].battlefield.forEach(c => {
              if (c && races.some(r => c.stRace === r || c.ndRace === r)) {
                count++;
              }
            });
          });
          return count;
        };

        // è¾…åŠ©å‡½æ•°ï¼šè·å–å¯¹æ–¹ç©å®¶
        const getOpponent = (player) => player === 'red' ? 'blue' : 'red';
        
        ['red', 'blue'].forEach(player => {
          const opponent = getOpponent(player);
          
          newState[player].battlefield.forEach((card, index) => {
            if (!card || !card.id) return;
            
            const config = window.CardEffectConfigs?.[card.id];
            if (!config || !config.passive) return;
            
            // é‡ç½®åˆ°åŸºç¡€å€¼
            if (!card.baseAtk) {
              const baseCard = allCards.find(c => c.id === card.id);
              if (baseCard) {
                card.baseAtk = baseCard.atk;
                card.baseHp = baseCard.hp;
              } else {
                console.warn('[Passive] æ‰¾ä¸åˆ°åŸºç¡€å¡ç‰Œæ•°æ®:', card.id, card.name);
                return;
              }
            }
            
            // é‡ç½®å±æ€§åˆ°åŸºç¡€å€¼
            card.atk = card.baseAtk;
            // hp ä¸é‡ç½®ï¼Œå› ä¸ºä¼¤å®³æ˜¯æ°¸ä¹…çš„
            // ä½† maxHp éœ€è¦é‡ç½®
            if (!card.baseMaxHp) {
              card.baseMaxHp = card.baseHp;
            }
            card.maxHp = card.baseMaxHp;
            
            console.log(`[Passive] é‡ç½® ${card.name} atk:${card.atk}, maxHp:${card.maxHp}`);
            
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            // æ¡ä»¶ç±»å‹å¤„ç†
            // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
            const condition = config.condition;
            if (!condition) return;

            // 1. countRace - åŸæœ‰çš„ç»Ÿè®¡å…¨åœºç§æ—ï¼ˆå‘åå…¼å®¹ï¼‰
            if (condition.type === 'countRace') {
              const { races, threshold, bonus } = condition;
              const count = countAllRaces(races);
              
              console.log(`[Passive] ${card.name} æ£€æµ‹åˆ° ${races.join('/')} æ•°é‡:`, count);
              
              if (count >= threshold) {
                if (bonus.atk) {
                  card.atk += bonus.atk;
                  console.log(`[Passive] ${card.name} atkåŠ æˆ:`, bonus.atk, 'â†’', card.atk);
                }
                if (bonus.hp) {
                  card.hp += bonus.hp;
                  card.maxHp += bonus.hp;
                  console.log(`[Passive] ${card.name} hpåŠ æˆ:`, bonus.hp);
                }
              }
            }
            
            // 2. countSelfRace - ç»Ÿè®¡å·±æ–¹ç§æ—æ•°é‡
            else if (condition.type === 'countSelfRace') {
              const { races, bonus } = condition;
              const count = countRaces(player, races);
              
              console.log(`[Passive] ${card.name} æ£€æµ‹åˆ°å·±æ–¹ ${races.join('/')} æ•°é‡:`, count);
              
              if (bonus.targetAll) {
                // ç»™å·±æ–¹å…¨ä½“åŠ æˆ
                newState[player].battlefield.forEach(c => {
                  if (c) {
                    if (bonus.atk) c.atk += bonus.atk * count;
                    if (bonus.hp) {
                      c.hp += bonus.hp * count;
                      c.maxHp += bonus.hp * count;
                    }
                  }
                });
                console.log(`[Passive] ${card.name} ç»™å…¨ä½“åŠ æˆ: atk+${bonus.atk * count}, hp+${bonus.hp * count}`);
              } else if (bonus.targetSelf) {
                // åªç»™è‡ªå·±åŠ æˆ
                if (bonus.atk) card.atk += bonus.atk * count;
                if (bonus.hp) {
                  card.hp += bonus.hp * count;
                  card.maxHp += bonus.hp * count;
                }
                console.log(`[Passive] ${card.name} è‡ªèº«åŠ æˆ: atk+${bonus.atk * count}, hp+${bonus.hp * count}`);
              } else {
                // é»˜è®¤ç»™è‡ªå·±åŠ æˆ
                if (bonus.atk) card.atk += bonus.atk * count;
                if (bonus.hp) {
                  card.hp += bonus.hp * count;
                  card.maxHp += bonus.hp * count;
                }
              }
            }
            
            // 3. countOpponentRace - ç»Ÿè®¡æ•Œæ–¹ç§æ—æ•°é‡
            else if (condition.type === 'countOpponentRace') {
              const { races, bonus } = condition;
              const count = countRaces(opponent, races);
              
              console.log(`[Passive] ${card.name} æ£€æµ‹åˆ°æ•Œæ–¹ ${races.join('/')} æ•°é‡:`, count);
              
              if (bonus.targetAll) {
                // ç»™å·±æ–¹å…¨ä½“åŠ æˆ
                newState[player].battlefield.forEach(c => {
                  if (c) {
                    if (bonus.atk) c.atk += bonus.atk * count;
                    if (bonus.hp) {
                      c.hp += bonus.hp * count;
                      c.maxHp += bonus.hp * count;
                    }
                  }
                });
              } else {
                // ç»™è‡ªå·±åŠ æˆ
                if (bonus.atk) card.atk += bonus.atk * count;
                if (bonus.hp) {
                  card.hp += bonus.hp * count;
                  card.maxHp += bonus.hp * count;
                }
              }
            }
            
            // 4. countAllRace - ç»Ÿè®¡å…¨åœºç§æ—æ•°é‡
            else if (condition.type === 'countAllRace') {
              const { races, bonus } = condition;
              const count = countAllRaces(races);
              
              console.log(`[Passive] ${card.name} æ£€æµ‹åˆ°å…¨åœº ${races.join('/')} æ•°é‡:`, count);
              
              if (bonus.targetSelf) {
                if (bonus.atk) card.atk += bonus.atk * count;
                if (bonus.hp) {
                  card.hp += bonus.hp * count;
                  card.maxHp += bonus.hp * count;
                }
              }
            }
            
            // 5. raceBonus - ç»™ç‰¹å®šç§æ—åŠ æˆ/å‡ç›Š
            else if (condition.type === 'raceBonus') {
              const { races, bonus } = condition;
              
              ['red', 'blue'].forEach(p => {
                newState[p].battlefield.forEach(c => {
                  if (c && races.some(r => c.stRace === r || c.ndRace === r)) {
                    if (bonus.atk) c.atk += bonus.atk;
                    if (bonus.hp) {
                      c.hp += bonus.hp;
                      c.maxHp += bonus.hp;
                    }
                  }
                });
              });
              
              console.log(`[Passive] ${card.name} ç»™ ${races.join('/')} ç§æ—åŠ æˆ`);
            }
            
            // 6. vsRaceBonus - å¯¹ç‰¹å®šç§æ—æˆ˜æ–—æ—¶åŠ æˆï¼ˆæ ‡è®°ï¼Œæˆ˜æ–—æ—¶æ£€æŸ¥ï¼‰
            else if (condition.type === 'vsRaceBonus') {
              card._vsRaceBonus = condition;
              console.log(`[Passive] ${card.name} å¯¹ ${condition.races.join('/')} æœ‰æˆ˜æ–—åŠ æˆ`);
            }
            
            // 7. multiBonus - å¤šé‡åŠ æˆ
            else if (condition.type === 'multiBonus') {
              const { bonuses } = condition;
              
              bonuses.forEach(bonusConfig => {
                const { type, races, bonus } = bonusConfig;
                
                if (type === 'countSelfRace') {
                  const count = countRaces(player, races);
                  
                  if (bonus.targetAll) {
                    newState[player].battlefield.forEach(c => {
                      if (c) {
                        if (bonus.atk) c.atk += bonus.atk * count;
                        if (bonus.hp) {
                          c.hp += bonus.hp * count;
                          c.maxHp += bonus.hp * count;
                        }
                      }
                    });
                  } else if (bonus.targetSelf) {
                    if (bonus.atk) card.atk += bonus.atk * count;
                    if (bonus.hp) {
                      card.hp += bonus.hp * count;
                      card.maxHp += bonus.hp * count;
                    }
                  }
                  
                  console.log(`[Passive] ${card.name} multiBonus - å·±æ–¹${races.join('/')}æ•°é‡:${count}`);
                }
                else if (type === 'countOpponentRace') {
                  const count = countRaces(opponent, races);
                  
                  if (bonus.targetAll) {
                    newState[player].battlefield.forEach(c => {
                      if (c) {
                        if (bonus.atk) c.atk += bonus.atk * count;
                        if (bonus.hp) {
                          c.hp += bonus.hp * count;
                          c.maxHp += bonus.hp * count;
                        }
                      }
                    });
                  } else if (bonus.targetSelf) {
                    if (bonus.atk) card.atk += bonus.atk * count;
                    if (bonus.hp) {
                      card.hp += bonus.hp * count;
                      card.maxHp += bonus.hp * count;
                    }
                  }
                  
                  console.log(`[Passive] ${card.name} multiBonus - æ•Œæ–¹${races.join('/')}æ•°é‡:${count}`);
                }
                else if (type === 'countAllRace') {
                  const count = countAllRaces(races);
                  
                  if (bonus.targetSelf) {
                    if (bonus.atk) card.atk += bonus.atk * count;
                    if (bonus.hp) {
                      card.hp += bonus.hp * count;
                      card.maxHp += bonus.hp * count;
                    }
                  }
                  
                  console.log(`[Passive] ${card.name} multiBonus - å…¨åœº${races.join('/')}æ•°é‡:${count}`);
                }
                else if (type === 'raceBonus') {
                  ['red', 'blue'].forEach(p => {
                    newState[p].battlefield.forEach(c => {
                      if (c && races.some(r => c.stRace === r || c.ndRace === r)) {
                        if (bonus.atk) c.atk += bonus.atk;
                        if (bonus.hp) {
                          c.hp += bonus.hp;
                          c.maxHp += bonus.hp;
                        }
                      }
                    });
                  });
                }
                else if (type === 'vsRaceBonus') {
                  // æˆ˜æ–—åŠ æˆæ ‡è®°
                  if (!card._vsRaceBonuses) card._vsRaceBonuses = [];
                  card._vsRaceBonuses.push(bonusConfig);
                }
              });
            }
          });
        });
        
        // âœ… ä¿®å¤å…¬çˆµbugï¼šè¢«åŠ¨æ•ˆæœå¯èƒ½å¯¼è‡´å¡ç‰Œæ­»äº¡ï¼Œéœ€è¦æ£€æŸ¥å¹¶ç§»é™¤
        ['red', 'blue'].forEach(player => {
          newState[player].battlefield = newState[player].battlefield.map((card, idx) => {
            if (card && card.hp <= 0) {
              console.log(`[Passiveæ­»äº¡æ£€æŸ¥] ${player}è·¯çº¿${idx+1}: ${card.name} hp=${card.hp} å·²æ­»äº¡`);
              newState.discardPile.push(card);
              newState.log.push(`${card.name} è¢«å‡»è´¥ï¼ˆè¢«åŠ¨æ•ˆæœå¯¼è‡´hpâ‰¤0ï¼‰`);
              return null;
            }
            return card;
          });
        });
        
        return newState;
      }, [allCards]);

      // â”€â”€ æ’å…¥å¼€å§‹ï¼šä½œå¼Šä»£ç  â”€â”€
      useEffect(() => {
        window.spawnCheatCard = () => {
          const input = document.getElementById("cheat-card-id");
          const id = Number(input?.value);

          if (!id || !allCards.length) return;

          // ä»æ‰€æœ‰åŸå§‹å¡ç‰Œæ•°æ®ä¸­æŸ¥æ‰¾
          const cardData = allCards.find(c => c.id === id);
          if (!cardData) {
            alert("æœªæ‰¾åˆ°è¯¥IDçš„å¡ç‰Œï¼");
            return;
          }

          // åˆ›å»ºå¸¦å®ä¾‹IDçš„å¡ç‰Œå¯¹è±¡
          const newCard = window.createCard(cardData);

          // âœ… æ ¹æ®å½“å‰é˜¶æ®µåˆ¤æ–­ç»™è°åˆ·ç‰Œ
          const currentPlayer = (gameState.phase === 'redDeploy' || gameState.phase === 'redSupport') 
            ? 'red' 
            : (gameState.phase === 'blueDeploy' || gameState.phase === 'blueSupport')
            ? 'blue'
            : 'red'; // é»˜è®¤çº¢æ–¹

          setGameState(prev => ({
            ...prev,
            [currentPlayer]: { 
              ...prev[currentPlayer], 
              hand: [...prev[currentPlayer].hand, newCard] 
            },
            log: [...prev.log, `[ä½œå¼Š] ${currentPlayer === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}è·å¾—å¡ç‰Œï¼š${newCard.name}`]
          }));
        };

        return () => delete window.spawnCheatCard;
      }, [allCards, gameState.phase]); // âœ… æ·»åŠ  gameState.phase ä¾èµ–
      // â”€â”€ æ’å…¥ç»“æŸ â”€â”€

      // â”€â”€ æ”¯æ´/å¥‡è¿¹ å±•ç¤ºè¾…åŠ©ï¼šæ˜¾ç¤ºå¡ç‰Œ N ç§’åè‡ªåŠ¨æ¶ˆå¤± â”€â”€
      const showCardOverlay = useCallback((card) => {
        setCardShowOverlay(card);
        const dur = card.type === 'miracle' ? 2000 : 1000;
        window.SoundManager.playSound(card.type === 'miracle' ? 'miracle' : 'place');
        setTimeout(() => setCardShowOverlay(null), dur);
      }, []);

      // â”€â”€ åˆå§‹åŒ– â”€â”€
      const initGame = useCallback(() => {
        if (!allCards.length) return;

        const regular  = allCards.filter(c => c.type !== 'miracle');
        const miracles = allCards.filter(c => c.type === 'miracle');

        const deck         = window.shuffleArray(regular.map(window.createCard));
        const miracleDeck  = window.shuffleArray(miracles.map(window.createCard));

        // çº¢è“å„æŠ½6å¼ ï¼ˆäº’ä¸é‡å ï¼‰
        const redSix  = deck.slice(0, 6);
        const blueSix = deck.slice(6, 12);
        const rest    = deck.slice(12);

        // å„æŠ½1å¼ å¥‡è¿¹
        const mDeck   = [...miracleDeck];
        const redM    = mDeck.pop();
        const blueM   = mDeck.pop();

        setGameState({
          ...INIT_STATE,
          red:  { ...INIT_STATE.red,  hand: redM  ? [redM]  : [] },
          blue: { ...INIT_STATE.blue, hand: blueM ? [blueM] : [] },
          deck: rest,
          miracleDeck: mDeck,
          initialCards: redSix,
          initialCardsBlue: blueSix,
          log: ['æ¸¸æˆåˆå§‹åŒ–å®Œæˆï¼', 'çº¢è“åŒæ–¹å„æŠ½å–1å¼ å¥‡è¿¹ç‰Œ', 'ç‚¹å‡»"å¼€å§‹é€‰ç‰Œ"è¿›å…¥é€‰ç‰Œé˜¶æ®µ']
        });
        setGamePhase('notStarted');
        setWinner(null);
      }, [allCards]);

      // å¡ç‰ŒåŠ è½½åè‡ªåŠ¨åˆå§‹åŒ–
      useEffect(() => { if (allCards.length) initGame(); }, [allCards, initGame]);

      // å¤ç›˜äº‹ä»¶ç›‘å¬ï¼ˆç‚¹å‡»"å¤ç›˜"æŒ‰é’®æ—¶éšè—èƒœåˆ©é®å±‚ï¼‰
      useEffect(() => {
        const handler = () => setWinner(null);
        window.addEventListener('gameui:review', handler);
        return () => window.removeEventListener('gameui:review', handler);
      }, []);

      // â”€â”€ å¼€å§‹é€‰ç‰Œ â”€â”€
      const startPicking = () => {
        setGamePhase('redPicking');
        addLog('--- çº¢æ–¹é€‰ç‰Œé˜¶æ®µ ---');
      };

      // â”€â”€ é€‰ç‰Œé€»è¾‘ â”€â”€
      const pickCard = (card) => {
        if (gamePhase === 'redPicking') {
          const newHand = [...gameState.red.hand, card];
          const remaining = gameState.initialCards.filter(c => c.instanceId !== card.instanceId);

          if (newHand.length === 3) {  // å·²æœ‰1å¥‡è¿¹ + åˆšé€‰ç¬¬2å¼  = 3 â†’ çº¢æ–¹é€‰ç‰Œå®Œ
            setGameState(prev => ({
              ...prev,
              red: { ...prev.red, hand: newHand },
              initialCards: prev.initialCardsBlue,   // åˆ‡æ¢åˆ°è“æ–¹çš„6å¼ 
              deck: window.shuffleArray([...prev.deck, ...remaining])
            }));
            setGamePhase('bluePicking');
            addLog('çº¢æ–¹é€‰ç‰Œå®Œæˆ â†’ è“æ–¹é€‰ç‰Œé˜¶æ®µ');
          } else {
            setGameState(prev => ({
              ...prev,
              red: { ...prev.red, hand: newHand },
              initialCards: remaining
            }));
            addLog(`çº¢æ–¹é€‰æ‹©äº† ${card.name}`);
          }

        } else if (gamePhase === 'bluePicking') {
          const newHand = [...gameState.blue.hand, card];
          const remaining = gameState.initialCards.filter(c => c.instanceId !== card.instanceId);

          if (newHand.length === 3) {
            setGameState(prev => ({
              ...prev,
              blue: { ...prev.blue, hand: newHand },
              initialCards: [],
              deck: window.shuffleArray([...prev.deck, ...remaining])
            }));
            setGamePhase('playing');
            addLog('è“æ–¹é€‰ç‰Œå®Œæˆ â†’ ç‚¹å‡»"ä¸‹ä¸€å›åˆ"å¼€å§‹æ¸¸æˆ');
          } else {
            setGameState(prev => ({
              ...prev,
              blue: { ...prev.blue, hand: newHand },
              initialCards: remaining
            }));
            addLog(`è“æ–¹é€‰æ‹©äº† ${card.name}`);
          }
        }
      };

      // â”€â”€ å¼€å§‹æ–°å›åˆ â”€â”€
      const startTurn = () => {
        const newTurn = gameState.turn + 1;
        const coins   = Math.min(newTurn, 10);
        const logs    = [`--- ç¬¬${newTurn}å›åˆå¼€å§‹ ---`, `åŒæ–¹è·å¾— ${coins} é‡‘å¸`];

        let deck      = [...gameState.deck];
        let redHand   = [...gameState.red.hand];
        let blueHand  = [...gameState.blue.hand];

        if (newTurn >= 2) {
          for (let i = 0; i < 2; i++) {
            const r = deck.pop(); if (r) redHand.push(r);
            const b = deck.pop(); if (b) blueHand.push(b);
          }
          logs.push('åŒæ–¹å„æŠ½2å¼ ç‰Œ');
        } else {
          logs.push('ç¬¬ä¸€å›åˆä¸æŠ½ç‰Œ');
        }

        // åˆ›å»ºæ–°çŠ¶æ€
        let newState = {
          ...gameState,
          turn: newTurn,
          phase: 'redDeploy',
          deck,
          red:  { ...gameState.red,  coins, hand: redHand },
          blue: { ...gameState.blue, coins, hand: blueHand },
          log: [...gameState.log, ...logs]
        };

        // âœ¨ è§¦å‘æ‰€æœ‰æˆ˜åœºç‰Œçš„ onTurnStart æ•ˆæœ
        if (newTurn >= 2) {  // ç¬¬ä¸€å›åˆä¸è§¦å‘
          console.log('[startTurn] æ£€æŸ¥ onTurnStart æ•ˆæœ, å›åˆ:', newTurn);
          ['red', 'blue'].forEach(player => {
            console.log(`[startTurn] æ£€æŸ¥${player}æ–¹æˆ˜åœº:`, newState[player].battlefield.filter(c => c).map(c => ({name: c.name, id: c.id})));
            newState[player].battlefield.forEach((card, index) => {
              if (card && card.id) {
                const config = window.CardEffectConfigs?.[card.id];
                console.log(`[startTurn] å¡ç‰Œ ${card.name} é…ç½®:`, config?.trigger, config?.passive);
                if (config && config.trigger === 'onTurnStart') {
                  console.log('[onTurnStart] è§¦å‘:', card.name, 'è·¯çº¿:', index);
                  
                  const effectContext = {
                    player,
                    card,
                    target: card,  // æŒ‡å‘è‡ªå·±
                    logCallback: (msg) => newState.log.push(msg)
                  };
                  
                  // è§¦å‘æ•ˆæœï¼Œè·å–æ›´æ–°åçš„çŠ¶æ€
                  const beforeState = JSON.stringify(newState[player].battlefield[index]);
                  newState = window.EffectEngine.trigger(card.id, effectContext, newState);
                  const afterState = JSON.stringify(newState[player].battlefield[index]);
                  console.log('[onTurnStart] æ•ˆæœå‰åå¯¹æ¯”:', beforeState === afterState ? 'æœªæ”¹å˜' : 'å·²æ”¹å˜');
                  console.log('[onTurnStart] å¡ç‰ŒçŠ¶æ€:', newState[player].battlefield[index]);
                }
              }
            });
          });
        }

        // âœ… æ¸…é™¤æŠ¤ç›¾å’Œå‡å°‘å†»ç»“å›åˆæ•°
        ['red', 'blue'].forEach(player => {
          newState[player].battlefield.forEach(card => {
            if (card) {
              // æ¸…é™¤æŠ¤ç›¾
              if (card._shield) {
                delete card._shield;
              }
              // å‡å°‘å†»ç»“å›åˆæ•°
              if (card._frozen && card._frozen > 0) {
                card._frozen--;
                if (card._frozen === 0) {
                  delete card._frozen;
                  newState.log.push(`${card.name} è§£é™¤å†»ç»“`);
                }
              }
            }
          });
        });

        setGameState(newState);
      };

      // â”€â”€ é€‰æ‹©æ‰‹ç‰Œ â”€â”€
      const selectCard = (card, player) => {
        if (gameState.phase === 'idle' || gameState.phase === 'battle') return;

        const isRedPhase = gameState.phase === 'redDeploy' || gameState.phase === 'redSupport';
        if ((isRedPhase && player !== 'red') || (!isRedPhase && player !== 'blue')) return;

        // åå¤ç‚¹å‡»åŒä¸€å¼  â†’ å–æ¶ˆé€‰æ‹©
        if (gameState.selectedCard?.instanceId === card.instanceId) {
          setGameState(prev => ({ ...prev, selectedCard: null }));
          return;
        }
        setGameState(prev => ({ ...prev, selectedCard: card }));
      };

      // â”€â”€ æ”¾ç½®æˆ˜åœºç‰Œ/å»ºç­‘ç‰Œ â”€â”€
      const playCard = (laneIndex, isBuilding = false) => {
        const card = gameState.selectedCard;
        if (!card || card.type !== 'battlefield') return;

        const player = (gameState.phase === 'redDeploy' || gameState.phase === 'redSupport') ? 'red' : 'blue';
        const playerState = gameState[player];

        if (playerState.coins < card.cost) { addLog('é‡‘å¸ä¸è¶³ï¼'); return; }
        
        // æ£€æŸ¥å¡ç‰Œæ˜¯å¦æ˜¯å»ºç­‘
        const cardIsBuilding = card.stRace === 'å»ºç­‘' || card.ndRace === 'å»ºç­‘';
        
        // å»ºç­‘ç‰Œåªèƒ½æ”¾åœ¨å»ºç­‘æ§½ï¼Œéå»ºç­‘ç‰Œåªèƒ½æ”¾åœ¨æˆ˜åœºæ§½
        if (cardIsBuilding && !isBuilding) {
          addLog('å»ºç­‘ç‰Œéœ€è¦æ”¾ç½®åœ¨å»ºç­‘æ§½ï¼');
          return;
        }
        if (!cardIsBuilding && isBuilding) {
          addLog('å»ºç­‘æ§½åªèƒ½æ”¾ç½®å»ºç­‘ç‰Œï¼');
          return;
        }
        
        // æ£€æŸ¥ç›®æ ‡æ§½ä½æ˜¯å¦å·²å ç”¨
        const targetSlot = isBuilding ? playerState.buildings : playerState.battlefield;
        if (targetSlot[laneIndex] !== null) {
          addLog(isBuilding ? 'è¯¥å»ºç­‘æ§½å·²æœ‰å»ºç­‘ï¼' : 'è¯¥è·¯çº¿å·²æœ‰å¡ç‰Œï¼');
          return;
        }

        window.SoundManager.playSound('place');

        // éƒ¨ç½²å¡ç‰Œæ—¶ä¿å­˜åŸºç¡€å±æ€§
        const deployedCard = {
          ...card,
          baseAtk: card.atk,
          baseHp: card.hp
        };

        // æ›´æ–°å¯¹åº”çš„æ§½ä½
        const newSlots = isBuilding ? 
          [...playerState.buildings] : 
          [...playerState.battlefield];
        newSlots[laneIndex] = deployedCard;

        let newState = {
          ...gameState,
          [player]: {
            ...playerState,
            ...(isBuilding ? { buildings: newSlots } : { battlefield: newSlots }),
            hand: playerState.hand.filter(c => c.instanceId !== card.instanceId),
            coins: playerState.coins - card.cost
          },
          selectedCard: null,
          log: [...gameState.log, `${player === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}åœ¨è·¯çº¿${laneIndex+1}æ”¾ç½®äº†${isBuilding ? 'å»ºç­‘' : 'æˆ˜åœºç‰Œ'} ${card.name}`]
        };

        // âœ¨ é‡æ–°è®¡ç®—æ‰€æœ‰è¢«åŠ¨æ•ˆæœï¼ˆå› ä¸ºåœºä¸Šå¡ç‰Œæ•°é‡æ”¹å˜ï¼‰
        newState = calculatePassiveEffects(newState);

        // âœ… éª‘å£«(42)ç‰¹æ®Šæ•ˆæœï¼šç™»åœºæ—¶æ£€æŸ¥è´µæ—æ•°é‡
        if (card.id === 42) {
          let nobleCount = 0;
          ['red', 'blue'].forEach(p => {
            newState[p].battlefield.forEach(c => {
              if (c && (c.stRace === 'è´µæ—' || c.ndRace === 'è´µæ—')) {
                nobleCount++;
              }
            });
          });
          
          if (nobleCount >= 2) {
            deployedCard._shield = 1;
            newState.log.push(`${card.name} è·å¾—1å›åˆæŠ¤ç›¾ï¼`);
            console.log('[éª‘å£«] è´µæ—>=2ï¼Œè·å¾—æŠ¤ç›¾');
          }
        }

        setGameState(newState);
      };

      // â”€â”€ å¤„ç†æˆ˜åœºå¡æ§½ç‚¹å‡»ï¼ˆæ”¯æŒäº¤æ¢æ¨¡å¼ï¼‰ â”€â”€
      const handleBattlefieldClick = (clickedPlayer, clickedLane) => {
        // å¦‚æœåœ¨äº¤æ¢æ¨¡å¼ä¸­
        if (swapMode) {
          if (!swapMode.firstSlot) {
            // ç¬¬ä¸€æ¬¡ç‚¹å‡»ï¼šé€‰æ‹©ç¬¬ä¸€å¼ å¡
            const card = gameState[clickedPlayer].battlefield[clickedLane];
            
            // æ£€æŸ¥æ¨¡å¼é™åˆ¶
            if (swapMode.type === 'reposition') {
              // ç©ºé—´æ³•æœ¯ï¼šåªèƒ½é€‰å·±æ–¹
              const player = (gameState.phase === 'redDeploy' || gameState.phase === 'redSupport') ? 'red' : 'blue';
              if (clickedPlayer !== player) {
                addLog('ç©ºé—´æ³•æœ¯åªèƒ½é‡æ’å·±æ–¹é˜µå‹ï¼');
                return;
              }
            }
            
            if (!card) {
              addLog('è¯¥ä½ç½®æ²¡æœ‰å¡ç‰Œï¼');
              return;
            }
            
            setSwapMode({ ...swapMode, firstSlot: { player: clickedPlayer, lane: clickedLane, card } });
            addLog(`é€‰ä¸­ ${card.name}ï¼Œè¯·ç‚¹å‡»ç›®æ ‡ä½ç½®...`);
          } else {
            // ç¬¬äºŒæ¬¡ç‚¹å‡»ï¼šæ‰§è¡Œäº¤æ¢
            const { firstSlot } = swapMode;
            
            // æ£€æŸ¥æ˜¯å¦ç‚¹å‡»åŒä¸€ä½ç½®
            if (firstSlot.player === clickedPlayer && firstSlot.lane === clickedLane) {
              addLog('è¯·é€‰æ‹©ä¸åŒçš„ä½ç½®ï¼');
              return;
            }
            
            // æ£€æŸ¥æ¨¡å¼é™åˆ¶
            if (swapMode.type === 'reposition' && firstSlot.player !== clickedPlayer) {
              addLog('ç©ºé—´æ³•æœ¯åªèƒ½åœ¨å·±æ–¹å†…äº¤æ¢ï¼');
              return;
            }
            
            // æ‰§è¡Œäº¤æ¢
            const newState = JSON.parse(JSON.stringify(gameState));
            const card1 = newState[firstSlot.player].battlefield[firstSlot.lane];
            const card2 = newState[clickedPlayer].battlefield[clickedLane];
            
            newState[firstSlot.player].battlefield[firstSlot.lane] = card2;
            newState[clickedPlayer].battlefield[clickedLane] = card1;
            
            addLog(`äº¤æ¢ ${card1?.name || 'ç©ºä½'} å’Œ ${card2?.name || 'ç©ºä½'}`);
            setGameState(newState);
            
            // æ ¹æ®æ¨¡å¼å†³å®šæ˜¯å¦ç»§ç»­
            if (swapMode.type === 'swapBattlefield') {
              // æ›¿åï¼šåªäº¤æ¢ä¸€æ¬¡ï¼Œç«‹å³ç»“æŸ
              finishSwapMode();
            } else {
              // ç©ºé—´æ³•æœ¯ï¼šå¯ä»¥ç»§ç»­äº¤æ¢
              setSwapMode({ ...swapMode, firstSlot: null });
              addLog('ç»§ç»­é€‰æ‹©æˆ–ç‚¹å‡»"å®Œæˆé‡æ’"...');
            }
          }
          return;
        }
        
        // éäº¤æ¢æ¨¡å¼ï¼šæ­£å¸¸éƒ¨ç½²/ä½¿ç”¨å¡ç‰Œé€»è¾‘
        const canDeploy = gameState.selectedCard?.type === 'battlefield' && 
                         ((gameState.phase === 'redDeploy' && clickedPlayer === 'red') ||
                          (gameState.phase === 'blueDeploy' && clickedPlayer === 'blue'));
        
        const canTarget = gameState.selectedCard && 
                         window.EffectEngine.needsTarget(gameState.selectedCard.id);
        
        if (canDeploy) {
          playCard(clickedLane);
        } else if (canTarget) {
          useCardOnTarget(clickedPlayer, clickedLane);
        }
      };

// â”€â”€ å®Œæˆäº¤æ¢æ¨¡å¼ â”€â”€
const finishSwapMode = () => {
  if (!swapMode) return;
  
  // æ£€æŸ¥æ˜¯å¦æ˜¯ç©ºé—´æ³•å¸ˆè§¦å‘çš„
  if (swapMode.spaceMage) {
    // ç©ºé—´æ³•å¸ˆè§¦å‘ï¼šæ ‡è®°å·²ä½¿ç”¨ï¼Œä¸æ¶ˆè€—å¡ç‰Œ
    const { player, lane } = swapMode.spaceMage;
    
    setGameState(prev => {
      const newState = { ...prev };
      const card = newState[player].battlefield[lane];
      if (card && card.id === 28) {
        card.usedAbilityThisPhase = true;
        newState.log = [...newState.log, `${card.name} å·²ä½¿ç”¨é‡ç½®ä½ç½®ï¼ˆæœ¬é˜¶æ®µï¼‰`];
      }
      return newState;
    });
  } else {
    // æ”¯æ´ç‰Œè§¦å‘ï¼šæ¶ˆè€—å¡ç‰Œ
    const card = swapMode.card;
    const player = (gameState.phase === 'redDeploy' || gameState.phase === 'redSupport') ? 'red' : 'blue';
    const cost = card.type === 'miracle' ? 0 : card.cost;
    
    setGameState(prev => ({
      ...prev,
      [player]: {
        ...prev[player],
        hand: prev[player].hand.filter(c => c.instanceId !== card.instanceId),
        coins: prev[player].coins - cost
      },
      discardPile: [...prev.discardPile, card],
      selectedCard: null,
      log: [...prev.log, `${card.name} ä½¿ç”¨å®Œæˆ`]
    }));
  }
  
  setSwapMode(null);
  window.SoundManager.playSound('click');
};

// â”€â”€ å–æ¶ˆäº¤æ¢æ¨¡å¼ â”€â”€
const cancelSwapMode = () => {
  setSwapMode(null);
  addLog('å–æ¶ˆæ“ä½œ');
};

      // â”€â”€ ä½¿ç”¨æ”¯æ´/å¥‡è¿¹ å¯¹å•ä½ â”€â”€
      const useCardOnTarget = (targetPlayer, laneIndex) => {
        const card = gameState.selectedCard;
        if (!card || (card.type !== 'support' && card.type !== 'miracle')) return;

        const player      = (gameState.phase === 'redDeploy' || gameState.phase === 'redSupport') ? 'red' : 'blue';
        const playerState = gameState[player];
        const target      = gameState[targetPlayer].battlefield[laneIndex];
        if (!target) { addLog('ç›®æ ‡ä½ç½®æ²¡æœ‰å•ä½ï¼'); return; }

        const cost = card.type === 'miracle' ? 0 : card.cost;
        if (playerState.coins < cost) { addLog('é‡‘å¸ä¸è¶³ï¼'); return; }

        addLog(`${player === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}å¯¹ ${target.name} ä½¿ç”¨äº† ${card.name}`);
        showCardOverlay(card);   // â† å±•ç¤ºæ”¯æ´/å¥‡è¿¹å¡ç‰Œï¼ˆå†…å«éŸ³æ•ˆï¼‰

        // âœ¨ è§¦å‘å¡ç‰Œæ•ˆæœ
        const effectContext = {
          player: player,
          card: card,
          target: target,
          logCallback: addLog
        };

        let newState = window.EffectEngine.trigger(card.id, effectContext, gameState);

        // æ‰£é™¤è´¹ç”¨å¹¶ç§»é™¤æ‰‹ç‰Œï¼ˆæ³¨æ„ï¼šä¿ç•™ newState ä¸­æ•ˆæœç³»ç»Ÿå·²ç»ä¿®æ”¹çš„æˆ˜åœºå¡ç‰Œï¼‰
        const newHand = newState[player].hand.filter(c => c.instanceId !== card.instanceId);
        const newCoins = newState[player].coins - cost;
        
        // åªæ›´æ–°æ‰‹ç‰Œå’Œé‡‘å¸ï¼Œä¿ç•™æˆ˜åœºçš„ä¿®æ”¹
        newState[player].hand = newHand;
        newState[player].coins = newCoins;
        newState.discardPile = [...newState.discardPile, card];
        newState.selectedCard = null;

        console.log('[useCardOnTarget] æ–°çŠ¶æ€æˆ˜åœº:', newState[targetPlayer].battlefield.map(c => c ? {name: c.name, atk: c.atk, hp: c.hp} : null));

          newState = checkAndRemoveDeadCards(newState);
      
        setGameState(newState);
      };
        

      // â”€â”€ æ£€æŸ¥å¹¶ç§»é™¤æ­»äº¡å¡ç‰Œ â”€â”€
      const checkAndRemoveDeadCards = (state) => {
        ['red', 'blue'].forEach(player => {
          state[player].battlefield = state[player].battlefield.map((card, idx) => {
            if (card && card.hp <= 0) {
              console.log(`[checkDead] ${player}è·¯çº¿${idx+1}: ${card.name} hp=${card.hp} å·²æ­»äº¡`);
              state.discardPile.push(card);
              state.log.push(`${card.name} è¢«å‡»è´¥ï¼ˆhpâ‰¤0ï¼‰`);
              return null;
            }
            return card;
          });
        });
        
        return state;
      };

      // â”€â”€ "ç¡®è®¤ä½¿ç”¨"ï¼ˆæ”¯æ´/å¥‡è¿¹ å¯¹ç©å®¶æœ¬èº«æˆ–æ— ç›®æ ‡æ•ˆæœï¼‰ â”€â”€
      const confirmUse = () => {
        const card = gameState.selectedCard;
        if (!card) return;

        const player      = (gameState.phase === 'redDeploy' || gameState.phase === 'redSupport') ? 'red' : 'blue';
        const playerState = gameState[player];
        const cost        = card.type === 'miracle' ? 0 : card.cost;
        if (playerState.coins < cost) { addLog('é‡‘å¸ä¸è¶³ï¼'); return; }

        // âœ¨ æ£€æŸ¥æ˜¯å¦æ˜¯äº¤æ¢æ¨¡å¼
        const config = window.CardEffectConfigs?.[card.id];
        if (config && config.requiresUIMode) {
          // å¼€å¯äº¤æ¢æ¨¡å¼
          const mode = config.requiresUIMode;
          setSwapMode({ type: mode, card, firstSlot: null });
          addLog(`${card.name}: è¯·é€‰æ‹©${
            mode === 'reposition' ? 'è¦ç§»åŠ¨çš„å¡ç‰Œï¼ˆå·±æ–¹ï¼‰' :
            mode === 'swapBattlefield' ? 'ç¬¬ä¸€å¼ è¦äº¤æ¢çš„å¡ç‰Œ' :
            'æ‰‹ç‰Œ'
          }...`);
          return;  // ä¸ç«‹å³æ¶ˆè€—å¡ç‰Œ
        }

        addLog(`${player === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}ä½¿ç”¨äº† ${card.name}`);
        showCardOverlay(card);   // â† å±•ç¤ºæ”¯æ´/å¥‡è¿¹å¡ç‰Œï¼ˆå†…å«éŸ³æ•ˆï¼‰

        // âœ¨ è§¦å‘å¡ç‰Œæ•ˆæœï¼ˆæ— ç›®æ ‡æˆ–å¯¹ç©å®¶è‡ªå·±ï¼‰
        const effectContext = {
          player: player,
          card: card,
          target: null,  // æ— ç›®æ ‡
          logCallback: addLog
        };

        let newState = window.EffectEngine.trigger(card.id, effectContext, gameState);

        // æ‰£é™¤è´¹ç”¨å¹¶ç§»é™¤æ‰‹ç‰Œï¼ˆä¿ç•™æ•ˆæœç³»ç»Ÿçš„ä¿®æ”¹ï¼‰
        const newHand = newState[player].hand.filter(c => c.instanceId !== card.instanceId);
        const newCoins = newState[player].coins - cost;
        
        newState[player].hand = newHand;
        newState[player].coins = newCoins;
        newState.discardPile = [...newState.discardPile, card];
        newState.selectedCard = null;

        console.log('[confirmUse] æ–°çŠ¶æ€:', newState);

        // âœ… å¤„ç†ç‰¹æ®Šæ ‡è®°
        // 1. å¤„å†³ï¼šç«‹å³èƒœåˆ©
        if (newState._immediateVictory) {
          const victor = newState._immediateVictory;
          setWinner(victor);
          delete newState._immediateVictory;
          setGameState(newState);
          return;
        }

        // âœ… æ£€æŸ¥å¹¶ç§»é™¤æ­»äº¡å¡ç‰Œï¼ˆç”¨äºåœ°ç‹±ä¹‹ä¸»ç­‰ä¿®æ”¹è¡€é‡çš„æ•ˆæœï¼‰
        ['red', 'blue'].forEach(player => {
          newState[player].battlefield = newState[player].battlefield.map((card, idx) => {
            if (card && card.hp <= 0) {
              console.log(`[confirmUseæ­»äº¡æ£€æŸ¥] ${player}è·¯çº¿${idx+1}: ${card.name} hp=${card.hp} å·²æ­»äº¡`);
              newState.discardPile.push(card);
              newState.log.push(`${card.name} è¢«å‡»è´¥ï¼ˆhpâ‰¤0ï¼‰`);
              return null;
            }
            return card;
          });
        });

        // 2. æœ«æ—¥ï¼šç«‹å³è¿›å…¥ä¸‹ä¸€å›åˆï¼ˆæœ€åå¤„ç†ï¼‰
        const shouldSkipTurn = newState._skipToNextTurn;
        if (shouldSkipTurn) {
          delete newState._skipToNextTurn;
        }

        setGameState(newState);
        
        // å»¶è¿Ÿè§¦å‘ä¸‹ä¸€å›åˆ
        if (shouldSkipTurn) {
          setTimeout(() => {
            setGameState(prevState => {
              // åŸºäºå½“å‰çŠ¶æ€ï¼ˆå·²æ¸…ç©ºæˆ˜åœºï¼‰åˆ›å»ºæ–°å›åˆ
              const newTurn = prevState.turn + 1;
              const coins = Math.min(newTurn, 10);
              const logs = [`--- ç¬¬${newTurn}å›åˆå¼€å§‹ ---`, `åŒæ–¹è·å¾— ${coins} é‡‘å¸`];
              
              let deck = [...prevState.deck];
              let redHand = [...prevState.red.hand];
              let blueHand = [...prevState.blue.hand];
              
              if (newTurn >= 2) {
                for (let i = 0; i < 2; i++) {
                  const r = deck.pop(); if (r) redHand.push(r);
                  const b = deck.pop(); if (b) blueHand.push(b);
                }
                logs.push('åŒæ–¹å„æŠ½2å¼ ç‰Œ');
              } else {
                logs.push('ç¬¬ä¸€å›åˆä¸æŠ½ç‰Œ');
              }
              
              return {
                ...prevState,
                turn: newTurn,
                phase: 'redDeploy',
                deck,
                red: { ...prevState.red, coins, hand: redHand },
                blue: { ...prevState.blue, coins, hand: blueHand },
                log: [...prevState.log, ...logs]
              };
            });
          }, 500);
        }
};
    

   


// â”€â”€ ç©ºé—´æ³•å¸ˆæ¿€æ´» â”€â”€
const activateSpaceMage = (player, lane) => {
  const card = gameState[player].battlefield[lane];
  
  if (!card || card.id !== 28) {
    addLog('é”™è¯¯ï¼šä¸æ˜¯ç©ºé—´æ³•å¸ˆï¼');
    return;
  }
  
  if (card.usedAbilityThisPhase) {
    addLog('ç©ºé—´æ³•å¸ˆæœ¬é˜¶æ®µå·²ä½¿ç”¨è¿‡é‡ç½®ä½ç½®ï¼');
    return;
  }
  
  setSwapMode({ 
    type: 'reposition', 
    spaceMage: { player, lane },
    firstSlot: null 
  });
  
  addLog(`${card.name}: è¿›å…¥é‡æ’æ¨¡å¼...`);
  window.SoundManager.playSound('click');
};

      // â”€â”€ ç»“æŸé˜¶æ®µ â”€â”€
      const endPhase = () => {

         // âœ¨ æ¸…é™¤æ‰€æœ‰ç©ºé—´æ³•å¸ˆçš„ä½¿ç”¨æ ‡è®°
  setGameState(prev => {
    const newState = { ...prev };
    ['red', 'blue'].forEach(player => {
      newState[player].battlefield.forEach(card => {
        if (card && card.id === 28) {
          card.usedAbilityThisPhase = false;
        }
      });
    });
    return newState;
  });
        const next = { redDeploy: 'blueDeploy', blueDeploy: 'redSupport', redSupport: 'battle' };
        const target = next[gameState.phase];

        if (target === 'battle') {
          setGameState(prev => ({ ...prev, phase: 'battle', selectedCard: null, log: [...prev.log, '--- æˆ˜æ–—é˜¶æ®µ ---'] }));
          setTimeout(resolveBattle, 500);
        } else {
          const names = { blueDeploy: 'è“æ–¹éƒ¨ç½²é˜¶æ®µ', redSupport: 'çº¢æ–¹æ”¯æ´é˜¶æ®µ' };
          setGameState(prev => ({ ...prev, phase: target, selectedCard: null, log: [...prev.log, `--- ${names[target]} ---`] }));
        }
      };

      // â”€â”€ æˆ˜æ–—ç»“ç®—ï¼ˆé€è·¯çº¿åŠ¨ç”»ï¼‰ â”€â”€
      const resolveBattle = async () => {
        // æ‹·è´å½“å‰çŠ¶æ€ç”¨äºé€æ­¥ä¿®æ”¹
        let redBF       = gameState.red.battlefield.map(c => c ? {...c} : null);
        let blueBF      = gameState.blue.battlefield.map(c => c ? {...c} : null);
        let redBuilding = gameState.red.buildings.map(c => c ? {...c} : null);
        let blueBuilding= gameState.blue.buildings.map(c => c ? {...c} : null);
        let redHP       = gameState.red.health;
        let blueHP      = gameState.blue.health;
        let discard     = [...gameState.discardPile];
        let logs        = [];

        for (let i = 0; i < 4; i++) {
  setBattleAnimation({ active: true, lane: i });
  window.SoundManager.playSound('attack');
  await new Promise(r => setTimeout(r, 1000));

  const rc = redBF[i], bc = blueBF[i];
  const rb = redBuilding[i], bb = blueBuilding[i];  // å»ºç­‘

  if (rc && bc) {
    // âœ… æ£€æŸ¥å†»ç»“çŠ¶æ€
    const rcFrozen = rc._frozen && rc._frozen > 0;
    const bcFrozen = bc._frozen && bc._frozen > 0;
    
    if (rcFrozen && bcFrozen) {
      logs.push(`è·¯çº¿${i+1}: ${rc.name} å’Œ ${bc.name} éƒ½è¢«å†»ç»“ï¼Œæ— æ³•è¡ŒåŠ¨`);
      continue;
    } else if (rcFrozen) {
      logs.push(`è·¯çº¿${i+1}: ${rc.name} è¢«å†»ç»“ï¼Œæ— æ³•æ”»å‡»`);
      // åªæœ‰è“æ–¹æ”»å‡»
      let damage = bc.atk;
      
      // å»ºç­‘æŠµæŒ¡
      if (damage > 0 && rb) {
        const absorbed = Math.min(damage, rb.hp);
        rb.hp -= absorbed;
        damage -= absorbed;
        logs.push(`  ğŸ° ${rb.name} æŠµæŒ¡äº† ${absorbed} ç‚¹ä¼¤å®³`);
        if (rb.hp <= 0) {
          discard.push(rb);
          redBuilding[i] = null;
          logs.push(`  ğŸ° ${rb.name} è¢«æ‘§æ¯`);
        }
      }
      
      rc.hp -= damage;
      logs.push(`  ${bc.name} æ”»å‡» ${rc.name} (å‰©ä½™${rc.hp}HP)`);
      
      if (rc.hp <= 0) {
        // å± é¾™å‹‡å£«æ£€æµ‹
        if (rc.id === 50 && !rc._usedAntiOneShot) {
          rc.hp = 1;
          rc._usedAntiOneShot = true;
          logs.push(`  âš¡ ${rc.name} ä¸å±ˆä¹‹å¿—è§¦å‘ï¼å¼ºåˆ¶ç»´æŒ1ç‚¹ç”Ÿå‘½`);
        } else {
          discard.push(rc);
          redBF[i] = null;
          logs.push(`  çº¢æ–¹ ${rc.name} è¢«å‡»è´¥`);
        }
      }
      continue;
    } else if (bcFrozen) {
      logs.push(`è·¯çº¿${i+1}: ${bc.name} è¢«å†»ç»“ï¼Œæ— æ³•æ”»å‡»`);
      // åªæœ‰çº¢æ–¹æ”»å‡»
      let damage = rc.atk;
      
      // å»ºç­‘æŠµæŒ¡
      if (damage > 0 && bb) {
        const absorbed = Math.min(damage, bb.hp);
        bb.hp -= absorbed;
        damage -= absorbed;
        logs.push(`  ğŸ° ${bb.name} æŠµæŒ¡äº† ${absorbed} ç‚¹ä¼¤å®³`);
        if (bb.hp <= 0) {
          discard.push(bb);
          blueBuilding[i] = null;
          logs.push(`  ğŸ° ${bb.name} è¢«æ‘§æ¯`);
        }
      }
      
      bc.hp -= damage;
      logs.push(`  ${rc.name} æ”»å‡» ${bc.name} (å‰©ä½™${bc.hp}HP)`);
      
      if (bc.hp <= 0) {
        // å± é¾™å‹‡å£«æ£€æµ‹
        if (bc.id === 50 && !bc._usedAntiOneShot) {
          bc.hp = 1;
          bc._usedAntiOneShot = true;
          logs.push(`  âš¡ ${bc.name} ä¸å±ˆä¹‹å¿—è§¦å‘ï¼å¼ºåˆ¶ç»´æŒ1ç‚¹ç”Ÿå‘½`);
        } else {
          discard.push(bc);
          blueBF[i] = null;
          logs.push(`  è“æ–¹ ${bc.name} è¢«å‡»è´¥`);
        }
      }
      continue;
    }
    
    // è®°å½•æˆ˜æ–—å‰ç”Ÿå‘½å€¼
    const rcHpBefore = rc.hp;
    const bcHpBefore = bc.hp;
    
    // âœ¨ è®¡ç®—æˆ˜æ–—æ—¶çš„ç§æ—åŠ æˆ
    let rcAtk = rc.atk;
    let bcAtk = bc.atk;

    // çº¢æ–¹å¯¹è“æ–¹çš„åŠ æˆ
    if (rc._vsRaceBonus) {
      const { races, bonus } = rc._vsRaceBonus;
      if (races.some(r => bc.stRace === r || bc.ndRace === r)) {
        if (bonus.atkMultiplier) {
          rcAtk *= bonus.atkMultiplier;
          logs.push(`  âš”ï¸ ${rc.name} å¯¹ ${bc.name} æ”»å‡»åŠ›Ã—${bonus.atkMultiplier}ï¼`);
        }
        if (bonus.atk) {
          rcAtk += bonus.atk;
          logs.push(`  âš”ï¸ ${rc.name} å¯¹ ${bc.name} æ”»å‡»åŠ›+${bonus.atk}ï¼`);
        }
      }
    }
    
    // çº¢æ–¹çš„å¤šé‡ç§æ—åŠ æˆ
    if (rc._vsRaceBonuses) {
      rc._vsRaceBonuses.forEach(({ races, bonus }) => {
        if (races.some(r => bc.stRace === r || bc.ndRace === r)) {
          if (bonus.atkMultiplier) {
            rcAtk *= bonus.atkMultiplier;
          }
          if (bonus.atk) {
            rcAtk += bonus.atk;
          }
        }
      });
    }

    // è“æ–¹å¯¹çº¢æ–¹çš„åŠ æˆ
    if (bc._vsRaceBonus) {
      const { races, bonus } = bc._vsRaceBonus;
      if (races.some(r => rc.stRace === r || rc.ndRace === r)) {
        if (bonus.atkMultiplier) {
          bcAtk *= bonus.atkMultiplier;
          logs.push(`  âš”ï¸ ${bc.name} å¯¹ ${rc.name} æ”»å‡»åŠ›Ã—${bonus.atkMultiplier}ï¼`);
        }
        if (bonus.atk) {
          bcAtk += bonus.atk;
          logs.push(`  âš”ï¸ ${bc.name} å¯¹ ${rc.name} æ”»å‡»åŠ›+${bonus.atk}ï¼`);
        }
      }
    }

    // è“æ–¹çš„å¤šé‡ç§æ—åŠ æˆ
    if (bc._vsRaceBonuses) {
      bc._vsRaceBonuses.forEach(({ races, bonus }) => {
        if (races.some(r => rc.stRace === r || rc.ndRace === r)) {
          if (bonus.atkMultiplier) {
            bcAtk *= bonus.atkMultiplier;
          }
          if (bonus.atk) {
            bcAtk += bonus.atk;
          }
        }
      });
    }

    // âœ… åˆºå®¢(45)é¦–æ¬¡æ”»å‡»åŠ æˆ
    if (rc.id === 45 && !rc._hasAttacked) {
      rcAtk *= 2;
      rc._hasAttacked = true;
      logs.push(`  ğŸ—¡ï¸ ${rc.name} é¦–æ¬¡æ”»å‡»ï¼æ”»å‡»åŠ›Ã—2`);
    }
    
    if (bc.id === 45 && !bc._hasAttacked) {
      bcAtk *= 2;
      bc._hasAttacked = true;
      logs.push(`  ğŸ—¡ï¸ ${bc.name} é¦–æ¬¡æ”»å‡»ï¼æ”»å‡»åŠ›Ã—2`);
    }
    
    // äº’ç›¸æ”»å‡»ï¼ˆä½¿ç”¨è®¡ç®—åçš„æ”»å‡»åŠ›ï¼‰
    // âœ… æŠ¤ç›¾æ£€æµ‹
    let rcDamage = bcAtk;
    let bcDamage = rcAtk;
    
    if (rc._shield && rc._shield > 0) {
      rcDamage = 0;
      rc._shield--;
      logs.push(`  ğŸ›¡ï¸ ${rc.name} çš„æŠ¤ç›¾æŠµæŒ¡äº†æ”»å‡»ï¼`);
    }
    
    if (bc._shield && bc._shield > 0) {
      bcDamage = 0;
      bc._shield--;
      logs.push(`  ğŸ›¡ï¸ ${bc.name} çš„æŠ¤ç›¾æŠµæŒ¡äº†æ”»å‡»ï¼`);
    }
    
    // âœ… å»ºç­‘æŠµæŒ¡ä¼¤å®³
    // çº¢æ–¹å»ºç­‘ä¸ºçº¢æ–¹æˆ˜åœºç‰ŒæŠµæŒ¡
    if (rcDamage > 0 && rb) {
      const absorbed = Math.min(rcDamage, rb.hp);
      rb.hp -= absorbed;
      rcDamage -= absorbed;
      logs.push(`  ğŸ° ${rb.name} ä¸º ${rc.name} æŠµæŒ¡äº† ${absorbed} ç‚¹ä¼¤å®³ï¼`);
      
      if (rb.hp <= 0) {
        discard.push(rb);
        redBuilding[i] = null;
        logs.push(`  ğŸ° ${rb.name} è¢«æ‘§æ¯`);
      }
    }
    
    // è“æ–¹å»ºç­‘ä¸ºè“æ–¹æˆ˜åœºç‰ŒæŠµæŒ¡
    if (bcDamage > 0 && bb) {
      const absorbed = Math.min(bcDamage, bb.hp);
      bb.hp -= absorbed;
      bcDamage -= absorbed;
      logs.push(`  ğŸ° ${bb.name} ä¸º ${bc.name} æŠµæŒ¡äº† ${absorbed} ç‚¹ä¼¤å®³ï¼`);
      
      if (bb.hp <= 0) {
        discard.push(bb);
        blueBuilding[i] = null;
        logs.push(`  ğŸ° ${bb.name} è¢«æ‘§æ¯`);
      }
    }
    
    // åº”ç”¨å‰©ä½™ä¼¤å®³åˆ°æˆ˜åœºç‰Œ
    rc.hp -= rcDamage;
    bc.hp -= bcDamage;
    
    // âœ… å± é¾™å‹‡å£«(50)å…ç§’æ€æ£€æµ‹
    if (rc.id === 50 && rc.hp <= 0 && !rc._usedAntiOneShot) {
      rc.hp = 1;
      rc._usedAntiOneShot = true;
      logs.push(`  âš¡ ${rc.name} ä¸å±ˆä¹‹å¿—è§¦å‘ï¼å¼ºåˆ¶ç»´æŒ1ç‚¹ç”Ÿå‘½`);
    }
    
    if (bc.id === 50 && bc.hp <= 0 && !bc._usedAntiOneShot) {
      bc.hp = 1;
      bc._usedAntiOneShot = true;
      logs.push(`  âš¡ ${bc.name} ä¸å±ˆä¹‹å¿—è§¦å‘ï¼å¼ºåˆ¶ç»´æŒ1ç‚¹ç”Ÿå‘½`);
    }
    
    logs.push(`è·¯çº¿${i+1}: ${rc.name}(${rc.hp}HP) VS ${bc.name}(${bc.hp}HP)`);
    
    // âœ… å¥³ä¼¯çˆµ(61)æ”»å‡»åå›è¡€
    if (rc.id === 61 && rcDamage > 0 && rc.hp > 0) {
      rc.hp += 1;
      rc.maxHp = Math.max(rc.maxHp, rc.hp);
      logs.push(`  ğŸ’‰ ${rc.name} å¸è¡€ï¼hp+1 (${rc.hp}HP)`);
    }
    
    if (bc.id === 61 && bcDamage > 0 && bc.hp > 0) {
      bc.hp += 1;
      bc.maxHp = Math.max(bc.maxHp, bc.hp);
      logs.push(`  ğŸ’‰ ${bc.name} å¸è¡€ï¼hp+1 (${bc.hp}HP)`);
    }
    
    // æ£€æŸ¥æ˜¯å¦æ­»äº¡
    const rcDied = rc.hp <= 0;
    const bcDied = bc.hp <= 0;
    
    // è®°å½•æ˜¯å¦è¢«æ”»å‡»
    const rcWasAttacked = rc.hp < rcHpBefore;
    const bcWasAttacked = bc.hp < bcHpBefore;
    
    // å¤„ç†çº¢æ–¹
    if (rcDied) {
      discard.push(rc);
      redBF[i] = null;
      logs.push(`  çº¢æ–¹ ${rc.name} è¢«å‡»è´¥`);
    } else if (rc.id === 16 && rcWasAttacked) {
      // ğŸº çº¢æ–¹ç‹¼äººè¢«æ”»å‡»åå­˜æ´»ï¼šå†æ¬¡è¡ŒåŠ¨
      logs.push(`  âš¡ ${rc.name} è§¦å‘ç‹¼æ€§ï¼šå†æ¬¡è¡ŒåŠ¨ï¼`);
      
      if (bc && !bcDied) {
        // å¯¹é¢è¿˜æ´»ç€ï¼Œæ”»å‡»å¯¹é¢
        bc.hp -= rc.atk;
        logs.push(`  ${rc.name} å†æ¬¡æ”»å‡» ${bc.name} (å‰©ä½™${bc.hp}HP)`);
        
        if (bc.hp <= 0) {
          discard.push(bc);
          blueBF[i] = null;
          logs.push(`  è“æ–¹ ${bc.name} è¢«å‡»è´¥`);
        }
      } else {
        // å¯¹é¢å·²æ­»ï¼Œæ”»å‡»ç©å®¶
        blueHP -= rc.atk;
        logs.push(`  ${rc.name} å¯¹è“æ–¹ç©å®¶é€ æˆ${rc.atk}ç‚¹ä¼¤å®³`);
      }
    }
    
    // å¤„ç†è“æ–¹
    if (bcDied && !rcDied) {
      discard.push(bc);
      blueBF[i] = null;
      logs.push(`  è“æ–¹ ${bc.name} è¢«å‡»è´¥`);
    } else if (bc && bc.id === 16 && bcWasAttacked && !bcDied) {
      // ğŸº è“æ–¹ç‹¼äººè¢«æ”»å‡»åå­˜æ´»ï¼šå†æ¬¡è¡ŒåŠ¨
      logs.push(`  âš¡ ${bc.name} è§¦å‘ç‹¼æ€§ï¼šå†æ¬¡è¡ŒåŠ¨ï¼`);
      
      if (rc && !rcDied) {
        // å¯¹é¢è¿˜æ´»ç€ï¼Œæ”»å‡»å¯¹é¢
        rc.hp -= bc.atk;
        logs.push(`  ${bc.name} å†æ¬¡æ”»å‡» ${rc.name} (å‰©ä½™${rc.hp}HP)`);
        
        if (rc.hp <= 0) {
          discard.push(rc);
          redBF[i] = null;
          logs.push(`  çº¢æ–¹ ${rc.name} è¢«å‡»è´¥`);
        }
      } else {
        // å¯¹é¢å·²æ­»ï¼Œæ”»å‡»ç©å®¶
        redHP -= bc.atk;
        logs.push(`  ${bc.name} å¯¹çº¢æ–¹ç©å®¶é€ æˆ${bc.atk}ç‚¹ä¼¤å®³`);
      }
    }
    
  } else if (rc) {
    // çº¢æ–¹å•æ–¹é¢æ”»å‡»
    blueHP -= rc.atk;
    logs.push(`è·¯çº¿${i+1}: ${rc.name} æ”»å‡»è“æ–¹ç©å®¶ï¼Œé€ æˆ ${rc.atk} ä¼¤å®³`);
    
    // ğŸº ç‹¼äººé¢å¤–æ”»å‡»ï¼ˆæ²¡æœ‰è¢«æ”»å‡»ä¹Ÿè§¦å‘ï¼‰
    if (rc.id === 16) {
      logs.push(`  âš¡ ${rc.name} ç‹¼æ€§çˆ†å‘ï¼šå†æ¬¡æ”»å‡»ï¼`);
      blueHP -= rc.atk;
      logs.push(`  ${rc.name} å†æ¬¡é€ æˆ${rc.atk}ç‚¹ä¼¤å®³`);
    }
    
  } else if (bc) {
    // è“æ–¹å•æ–¹é¢æ”»å‡»
    redHP -= bc.atk;
    logs.push(`è·¯çº¿${i+1}: ${bc.name} æ”»å‡»çº¢æ–¹ç©å®¶ï¼Œé€ æˆ ${bc.atk} ä¼¤å®³`);
    
    // ğŸº ç‹¼äººé¢å¤–æ”»å‡»ï¼ˆæ²¡æœ‰è¢«æ”»å‡»ä¹Ÿè§¦å‘ï¼‰
    if (bc.id === 16) {
      logs.push(`  âš¡ ${bc.name} ç‹¼æ€§çˆ†å‘ï¼šå†æ¬¡æ”»å‡»ï¼`);
      redHP -= bc.atk;
      logs.push(`  ${bc.name} å†æ¬¡é€ æˆ${bc.atk}ç‚¹ä¼¤å®³`);
    }
  }
}

        setBattleAnimation({ active: false, lane: -1 });

        // å¥‡è¿¹ç‰Œé‡Œç¨‹ç¢‘æŠ½å–
        let newMDeck = [...gameState.miracleDeck];
        let redHand  = [...gameState.red.hand];
        let blueHand = [...gameState.blue.hand];
        let redDrawn = [...gameState.red.miracleDrawn];
        let blueDrawn= [...gameState.blue.miracleDrawn];

        const milestones = [25, 20, 15, 10, 5];
        const drawMiracle = (hp, drawn, hand) => {
          const hit = milestones.some(m => hp <= m && !drawn.includes(m));
          if (hit) {
            const newDrawn = [...drawn, ...milestones.filter(m => hp <= m && !drawn.includes(m))];
            const card = newMDeck.pop();
            if (card) {
              hand.push(card);
              return { drawn: newDrawn, drewName: card.name };
            }
            return { drawn: newDrawn, drewName: null };
          }
          return { drawn, drewName: null };
        };

        if (redHP < gameState.red.health) {
          const res = drawMiracle(redHP, redDrawn, redHand);
          redDrawn = res.drawn;
          if (res.drewName) logs.push(`çº¢æ–¹è¡€é‡é™è‡³ ${redHP}ï¼ŒæŠ½å–å¥‡è¿¹ç‰Œï¼š${res.drewName}`);
        }
        if (blueHP < gameState.blue.health) {
          const res = drawMiracle(blueHP, blueDrawn, blueHand);
          blueDrawn = res.drawn;
          if (res.drewName) logs.push(`è“æ–¹è¡€é‡é™è‡³ ${blueHP}ï¼ŒæŠ½å–å¥‡è¿¹ç‰Œï¼š${res.drewName}`);
        }

        // åˆ¤èƒœ
        if (redHP <= 0 || blueHP <= 0) {
          const w = redHP > blueHP ? 'çº¢æ–¹' : (blueHP > redHP ? 'è“æ–¹' : 'å¹³å±€');
          logs.push(`ğŸ‰ ${w === 'å¹³å±€' ? 'å¹³å±€ï¼åŒæ–¹è¡€é‡ç›¸åŒ' : w + 'è·èƒœï¼å¯¹æ‰‹ç”Ÿå‘½å½’é›¶'}`);
          window.SoundManager.playSound('victory');
          setWinner(w);
        } else {
          logs.push('æˆ˜æ–—ç»“ç®—å®Œæˆ');
        }

        // æ›´æ–°çŠ¶æ€
        let finalState = {
          ...gameState,
          phase: 'idle',
          red:  { ...gameState.red,  battlefield: redBF,  buildings: redBuilding,  health: redHP,  hand: redHand,  miracleDrawn: redDrawn },
          blue: { ...gameState.blue, battlefield: blueBF, buildings: blueBuilding, health: blueHP, hand: blueHand, miracleDrawn: blueDrawn },
          miracleDeck: newMDeck,
          discardPile: discard,
          log: [...gameState.log, ...logs]
        };

        // âœ¨ è®¡ç®—æ‰€æœ‰è¢«åŠ¨æ•ˆæœ
        finalState = calculatePassiveEffects(finalState);

        setGameState(finalState);

        // ç‰Œåº“è€—å°½æ£€æŸ¥ï¼ˆå»¶è¿Ÿä¸€å¸§ç¡®ä¿ state æ›´æ–°åå†åˆ¤ï¼‰
        setTimeout(() => {
          setGameState(prev => {
            if (prev.deck.length === 0 && prev.red.hand.length === 0 && prev.blue.hand.length === 0 && !winner) {
              const w = prev.red.health > prev.blue.health ? 'çº¢æ–¹' : (prev.blue.health > prev.red.health ? 'è“æ–¹' : 'å¹³å±€');
              setWinner(w);
              window.SoundManager.playSound('victory');
              return { ...prev, log: [...prev.log, '--- ç‰Œåº“è€—å°½ ---', `çº¢æ–¹:${prev.red.health} | è“æ–¹:${prev.blue.health}`, `${w === 'å¹³å±€' ? 'å¹³å±€' : w + 'è·èƒœ'}`] };
            }
            return prev;
          });
        }, 100);
      };

      // â”€â”€ é‡ç½® â”€â”€
      const reset = () => {
        setWinner(null);
        setGamePhase('notStarted');
        setBattleAnimation({ active: false, lane: -1 });
        initGame();
      };

      // â”€â”€ æ¸²æŸ“ â”€â”€
      if (!uiReady) return <div className="text-white text-center mt-40 text-xl">åŠ è½½ä¸­â€¦</div>;

      return (
        <GameUI
          gameState={gameState}
          gamePhase={gamePhase}
          allCards={allCards}
          winner={winner}
          battleAnimation={battleAnimation}
          cardShowOverlay={cardShowOverlay}
          swapMode={swapMode}
          onStartPicking={startPicking}
          onPickCard={pickCard}
          onStartTurn={startTurn}
          onSelectCard={selectCard}
          onPlayCard={playCard}
          onUseCardOnTarget={useCardOnTarget}
          onConfirmUse={confirmUse}
          onEndPhase={endPhase}
          onReset={reset}
          onBattlefieldClick={handleBattlefieldClick}
          onFinishSwap={finishSwapMode}
          onCancelSwap={cancelSwapMode}
          onActivateSpaceMage={activateSpaceMage}
          hideOpponentHand={false}
          myRole={null}
        />
      );
    };

    ReactDOM.render(<LocalGame />, document.getElementById('root'));
    </script>

   
</body>
</html>
