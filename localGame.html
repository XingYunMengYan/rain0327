<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å››è·¯çº¿å¡ç‰Œå¯¹æˆ˜ â€” é¢å¯¹é¢æ¨¡å¼</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

    <!-- å…±äº«å·¥å…·åº“ï¼ˆçº¯JSï¼Œæ— JSXï¼‰ -->
    <script src="shared.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
    // ============================================================
    // localGame â€” é¢å¯¹é¢æ¨¡å¼é€»è¾‘å±‚
    // UI å…¨éƒ¨ç”± GameUI ç»„ä»¶è´Ÿè´£ï¼Œæ­¤å¤„åªå†™ state + è§„åˆ™
    // ============================================================
    const { useState, useEffect, useCallback } = React;

    const LocalGame = () => {
      // â”€â”€ ç­‰å¾… GameUI åŠ è½½å®Œæˆ â”€â”€
      const [uiReady, setUiReady] = useState(false);

      useEffect(() => {
        window.GameUILoader.load().then(() => setUiReady(true));
        // æ¢å¤éŸ³æ•ˆè®¾ç½®
        window.SoundManager.restoreFromStorage();
      }, []);

      // â”€â”€ å¡ç‰Œæ•°æ® â”€â”€
      const [allCards, setAllCards] = useState([]);

      useEffect(() => {
        window.loadCards()
          .then(cards => setAllCards(cards))
          .catch(err => {
            console.error('åŠ è½½å¡ç‰Œå¤±è´¥', err);
            alert('æ— æ³•åŠ è½½ card_data.csvï¼Œè¯·ç¡®ä¿æ–‡ä»¶åœ¨åŒä¸€ç›®å½•ä¸‹å¹¶é€šè¿‡æœ¬åœ°æœåŠ¡å™¨è®¿é—®ã€‚');
          });
      }, []);

      // â”€â”€ æ¸¸æˆæ ¸å¿ƒçŠ¶æ€ â”€â”€
      const INIT_STATE = {
        turn: 0,
        phase: 'idle',   // idle | redDeploy | blueDeploy | redSupport | battle
        red:  { health: 30, coins: 0, hand: [], battlefield: [null,null,null,null], miracleDrawn: [30] },
        blue: { health: 30, coins: 0, hand: [], battlefield: [null,null,null,null], miracleDrawn: [30] },
        deck: [],
        miracleDeck: [],
        discardPile: [],
        initialCards: [],        // å½“å‰é€‰ç‰Œé˜¶æ®µå¾…é€‰çš„6å¼ 
        initialCardsBlue: [],    // è“æ–¹å¾…é€‰çš„6å¼ ï¼ˆçº¢æ–¹é€‰å®Œåæ›¿æ¢ï¼‰
        selectedCard: null,
        log: []
      };

      const [gameState,       setGameState]      = useState(INIT_STATE);
      const [gamePhase,       setGamePhase]      = useState('notStarted');
      const [winner,          setWinner]         = useState(null);
      const [battleAnimation, setBattleAnimation] = useState({ active: false, lane: -1 });
      const [cardShowOverlay, setCardShowOverlay] = useState(null);  // æ”¯æ´/å¥‡è¿¹å±•ç¤º

      // â”€â”€ æ—¥å¿—è¾…åŠ© â”€â”€
      const addLog = useCallback((msg) => {
        setGameState(prev => ({ ...prev, log: [...prev.log, msg] }));
      }, []);

      // â”€â”€ æ”¯æ´/å¥‡è¿¹ å±•ç¤ºè¾…åŠ©ï¼šæ˜¾ç¤ºå¡ç‰Œ N ç§’åè‡ªåŠ¨æ¶ˆå¤± â”€â”€
      const showCardOverlay = useCallback((card) => {
        setCardShowOverlay(card);
        const dur = card.type === 'miracle' ? 2000 : 2000;
        window.SoundManager.playSound(card.type === 'miracle' ? 'miracle' : 'place');
        setTimeout(() => setCardShowOverlay(null), dur);
      }, []);

      // â”€â”€ åˆå§‹åŒ– â”€â”€
      const initGame = useCallback(() => {
        if (!allCards.length) return;

        const regular  = allCards.filter(c => c.type !== 'miracle');
        const miracles = allCards.filter(c => c.type === 'miracle');

        const deck         = window.shuffleArray(regular.map(window.createCard));
        const miracleDeck  = window.shuffleArray(miracles.map(window.createCard));

        // çº¢è“å„æŠ½6å¼ ï¼ˆäº’ä¸é‡å ï¼‰
        const redSix  = deck.slice(0, 6);
        const blueSix = deck.slice(6, 12);
        const rest    = deck.slice(12);

        // å„æŠ½1å¼ å¥‡è¿¹
        const mDeck   = [...miracleDeck];
        const redM    = mDeck.pop();
        const blueM   = mDeck.pop();

        setGameState({
          ...INIT_STATE,
          red:  { ...INIT_STATE.red,  hand: redM  ? [redM]  : [] },
          blue: { ...INIT_STATE.blue, hand: blueM ? [blueM] : [] },
          deck: rest,
          miracleDeck: mDeck,
          initialCards: redSix,
          initialCardsBlue: blueSix,
          log: ['æ¸¸æˆåˆå§‹åŒ–å®Œæˆï¼', 'çº¢è“åŒæ–¹å„æŠ½å–1å¼ å¥‡è¿¹ç‰Œ', 'ç‚¹å‡»"å¼€å§‹é€‰ç‰Œ"è¿›å…¥é€‰ç‰Œé˜¶æ®µ']
        });
        setGamePhase('notStarted');
        setWinner(null);
      }, [allCards]);

      // å¡ç‰ŒåŠ è½½åè‡ªåŠ¨åˆå§‹åŒ–
      useEffect(() => { if (allCards.length) initGame(); }, [allCards, initGame]);

      // å¤ç›˜äº‹ä»¶ç›‘å¬ï¼ˆç‚¹å‡»"å¤ç›˜"æŒ‰é’®æ—¶éšè—èƒœåˆ©é®å±‚ï¼‰
      useEffect(() => {
        const handler = () => setWinner(null);
        window.addEventListener('gameui:review', handler);
        return () => window.removeEventListener('gameui:review', handler);
      }, []);

      // â”€â”€ å¼€å§‹é€‰ç‰Œ â”€â”€
      const startPicking = () => {
        setGamePhase('redPicking');
        addLog('--- çº¢æ–¹é€‰ç‰Œé˜¶æ®µ ---');
      };

      // â”€â”€ é€‰ç‰Œé€»è¾‘ â”€â”€
      const pickCard = (card) => {
        if (gamePhase === 'redPicking') {
          const newHand = [...gameState.red.hand, card];
          const remaining = gameState.initialCards.filter(c => c.instanceId !== card.instanceId);

          if (newHand.length === 3) {  // å·²æœ‰1å¥‡è¿¹ + åˆšé€‰ç¬¬2å¼  = 3 â†’ çº¢æ–¹é€‰ç‰Œå®Œ
            setGameState(prev => ({
              ...prev,
              red: { ...prev.red, hand: newHand },
              initialCards: prev.initialCardsBlue,   // åˆ‡æ¢åˆ°è“æ–¹çš„6å¼ 
              deck: window.shuffleArray([...prev.deck, ...remaining])
            }));
            setGamePhase('bluePicking');
            addLog('çº¢æ–¹é€‰ç‰Œå®Œæˆ â†’ è“æ–¹é€‰ç‰Œé˜¶æ®µ');
          } else {
            setGameState(prev => ({
              ...prev,
              red: { ...prev.red, hand: newHand },
              initialCards: remaining
            }));
            addLog(`çº¢æ–¹é€‰æ‹©äº† ${card.name}`);
          }

        } else if (gamePhase === 'bluePicking') {
          const newHand = [...gameState.blue.hand, card];
          const remaining = gameState.initialCards.filter(c => c.instanceId !== card.instanceId);

          if (newHand.length === 3) {
            setGameState(prev => ({
              ...prev,
              blue: { ...prev.blue, hand: newHand },
              initialCards: [],
              deck: window.shuffleArray([...prev.deck, ...remaining])
            }));
            setGamePhase('playing');
            addLog('è“æ–¹é€‰ç‰Œå®Œæˆ â†’ ç‚¹å‡»"ä¸‹ä¸€å›åˆ"å¼€å§‹æ¸¸æˆ');
          } else {
            setGameState(prev => ({
              ...prev,
              blue: { ...prev.blue, hand: newHand },
              initialCards: remaining
            }));
            addLog(`è“æ–¹é€‰æ‹©äº† ${card.name}`);
          }
        }
      };

      // â”€â”€ å¼€å§‹æ–°å›åˆ â”€â”€
      const startTurn = () => {
        const newTurn = gameState.turn + 1;
        const coins   = Math.min(newTurn, 10);
        const logs    = [`--- ç¬¬${newTurn}å›åˆå¼€å§‹ ---`, `åŒæ–¹è·å¾— ${coins} é‡‘å¸`];

        let deck      = [...gameState.deck];
        let redHand   = [...gameState.red.hand];
        let blueHand  = [...gameState.blue.hand];

        if (newTurn >= 2) {
          for (let i = 0; i < 2; i++) {
            const r = deck.pop(); if (r) redHand.push(r);
            const b = deck.pop(); if (b) blueHand.push(b);
          }
          logs.push('åŒæ–¹å„æŠ½2å¼ ç‰Œ');
        } else {
          logs.push('ç¬¬ä¸€å›åˆä¸æŠ½ç‰Œ');
        }

        setGameState(prev => ({
          ...prev,
          turn: newTurn,
          phase: 'redDeploy',
          deck,
          red:  { ...prev.red,  coins, hand: redHand },
          blue: { ...prev.blue, coins, hand: blueHand },
          log: [...prev.log, ...logs]
        }));
      };

      // â”€â”€ é€‰æ‹©æ‰‹ç‰Œ â”€â”€
      const selectCard = (card, player) => {
        if (gameState.phase === 'idle' || gameState.phase === 'battle') return;

        const isRedPhase = gameState.phase === 'redDeploy' || gameState.phase === 'redSupport';
        if ((isRedPhase && player !== 'red') || (!isRedPhase && player !== 'blue')) return;

        // åå¤ç‚¹å‡»åŒä¸€å¼  â†’ å–æ¶ˆé€‰æ‹©
        if (gameState.selectedCard?.instanceId === card.instanceId) {
          setGameState(prev => ({ ...prev, selectedCard: null }));
          return;
        }
        setGameState(prev => ({ ...prev, selectedCard: card }));
      };

      // â”€â”€ æ”¾ç½®æˆ˜åœºç‰Œ â”€â”€
      const playCard = (laneIndex) => {
        const card = gameState.selectedCard;
        if (!card || card.type !== 'battlefield') return;

        const player      = (gameState.phase === 'redDeploy' || gameState.phase === 'redSupport') ? 'red' : 'blue';
        const playerState = gameState[player];

        if (playerState.coins < card.cost) { addLog('é‡‘å¸ä¸è¶³ï¼'); return; }
        if (playerState.battlefield[laneIndex] !== null) { addLog('è¯¥è·¯çº¿å·²æœ‰å¡ç‰Œï¼'); return; }

        window.SoundManager.playSound('place');

        const bf = [...playerState.battlefield];
        bf[laneIndex] = { ...card };

        setGameState(prev => ({
          ...prev,
          [player]: {
            ...playerState,
            battlefield: bf,
            hand:  playerState.hand.filter(c => c.instanceId !== card.instanceId),
            coins: playerState.coins - card.cost
          },
          selectedCard: null,
          log: [...prev.log, `${player === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}åœ¨è·¯çº¿${laneIndex+1}æ”¾ç½®äº† ${card.name}`]
        }));
      };

      // â”€â”€ ä½¿ç”¨æ”¯æ´/å¥‡è¿¹ å¯¹å•ä½ â”€â”€
      const useCardOnTarget = (targetPlayer, laneIndex) => {
        const card = gameState.selectedCard;
        if (!card || (card.type !== 'support' && card.type !== 'miracle')) return;

        const player      = (gameState.phase === 'redDeploy' || gameState.phase === 'redSupport') ? 'red' : 'blue';
        const playerState = gameState[player];
        const target      = gameState[targetPlayer].battlefield[laneIndex];
        if (!target) { addLog('ç›®æ ‡ä½ç½®æ²¡æœ‰å•ä½ï¼'); return; }

        const cost = card.type === 'miracle' ? 0 : card.cost;
        if (playerState.coins < cost) { addLog('é‡‘å¸ä¸è¶³ï¼'); return; }

        addLog(`${player === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}å¯¹ ${target.name} ä½¿ç”¨äº† ${card.name}`);
        showCardOverlay(card);   // â† å±•ç¤ºæ”¯æ´/å¥‡è¿¹å¡ç‰Œï¼ˆå†…å«éŸ³æ•ˆï¼‰

        setGameState(prev => ({
          ...prev,
          [player]: {
            ...playerState,
            hand:  playerState.hand.filter(c => c.instanceId !== card.instanceId),
            coins: playerState.coins - cost
          },
          discardPile: [...prev.discardPile, card],
          selectedCard: null
        }));
      };

      // â”€â”€ "ç¡®è®¤ä½¿ç”¨"ï¼ˆæ”¯æ´/å¥‡è¿¹ å¯¹ç©å®¶æœ¬èº«ï¼‰ â”€â”€
      const confirmUse = () => {
        const card = gameState.selectedCard;
        if (!card) return;

        const player      = (gameState.phase === 'redDeploy' || gameState.phase === 'redSupport') ? 'red' : 'blue';
        const playerState = gameState[player];
        const cost        = card.type === 'miracle' ? 0 : card.cost;
        if (playerState.coins < cost) { addLog('é‡‘å¸ä¸è¶³ï¼'); return; }

        addLog(`${player === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}ä½¿ç”¨äº† ${card.name}`);
        showCardOverlay(card);   // â† å±•ç¤ºæ”¯æ´/å¥‡è¿¹å¡ç‰Œï¼ˆå†…å«éŸ³æ•ˆï¼‰

        setGameState(prev => ({
          ...prev,
          [player]: {
            ...playerState,
            hand:  playerState.hand.filter(c => c.instanceId !== card.instanceId),
            coins: playerState.coins - cost
          },
          discardPile: [...prev.discardPile, card],
          selectedCard: null
        }));
      };

      // â”€â”€ ç»“æŸé˜¶æ®µ â”€â”€
      const endPhase = () => {
        const next = { redDeploy: 'blueDeploy', blueDeploy: 'redSupport', redSupport: 'battle' };
        const target = next[gameState.phase];

        if (target === 'battle') {
          setGameState(prev => ({ ...prev, phase: 'battle', selectedCard: null, log: [...prev.log, '--- æˆ˜æ–—é˜¶æ®µ ---'] }));
          setTimeout(resolveBattle, 500);
        } else {
          const names = { blueDeploy: 'è“æ–¹éƒ¨ç½²é˜¶æ®µ', redSupport: 'çº¢æ–¹æ”¯æ´é˜¶æ®µ' };
          setGameState(prev => ({ ...prev, phase: target, selectedCard: null, log: [...prev.log, `--- ${names[target]} ---`] }));
        }
      };

      // â”€â”€ æˆ˜æ–—ç»“ç®—ï¼ˆé€è·¯çº¿åŠ¨ç”»ï¼‰ â”€â”€
      const resolveBattle = async () => {
        // æ‹·è´å½“å‰çŠ¶æ€ç”¨äºé€æ­¥ä¿®æ”¹
        // æ³¨æ„ï¼šReact state åœ¨ async é‡Œä¼šè¿‡æœŸï¼Œè¿™é‡Œç”¨ ref æŠ€å·§
        // ä½†ä¸ºäº†ç®€æ´æˆ‘ä»¬ç›´æ¥ç”¨å‡½æ•°å¼ setGameState æœ€åä¸€æ¬¡å†™å…¥
        let redBF    = gameState.red.battlefield.map(c => c ? {...c} : null);
        let blueBF   = gameState.blue.battlefield.map(c => c ? {...c} : null);
        let redHP    = gameState.red.health;
        let blueHP   = gameState.blue.health;
        let discard  = [...gameState.discardPile];
        let logs     = [];

        for (let i = 0; i < 4; i++) {
          setBattleAnimation({ active: true, lane: i });
          window.SoundManager.playSound('attack');
          await new Promise(r => setTimeout(r, 1000));

          const rc = redBF[i], bc = blueBF[i];

          if (rc && bc) {
            rc.hp -= bc.atk;
            bc.hp -= rc.atk;
            logs.push(`è·¯çº¿${i+1}: ${rc.name}(${rc.hp}HP) VS ${bc.name}(${bc.hp}HP)`);
            if (rc.hp <= 0) { discard.push(rc); redBF[i]  = null; logs.push(`  çº¢æ–¹ ${rc.name} è¢«å‡»è´¥`); }
            if (bc.hp <= 0) { discard.push(bc); blueBF[i] = null; logs.push(`  è“æ–¹ ${bc.name} è¢«å‡»è´¥`); }
          } else if (rc) {
            blueHP -= rc.atk;
            logs.push(`è·¯çº¿${i+1}: ${rc.name} æ”»å‡»è“æ–¹ç©å®¶ï¼Œé€ æˆ ${rc.atk} ä¼¤å®³`);
          } else if (bc) {
            redHP -= bc.atk;
            logs.push(`è·¯çº¿${i+1}: ${bc.name} æ”»å‡»çº¢æ–¹ç©å®¶ï¼Œé€ æˆ ${bc.atk} ä¼¤å®³`);
          }
        }

        setBattleAnimation({ active: false, lane: -1 });

        // å¥‡è¿¹ç‰Œé‡Œç¨‹ç¢‘æŠ½å–
        let newMDeck = [...gameState.miracleDeck];
        let redHand  = [...gameState.red.hand];
        let blueHand = [...gameState.blue.hand];
        let redDrawn = [...gameState.red.miracleDrawn];
        let blueDrawn= [...gameState.blue.miracleDrawn];

        const milestones = [25, 20, 15, 10, 5];
        const drawMiracle = (hp, drawn, hand) => {
          const hit = milestones.some(m => hp <= m && !drawn.includes(m));
          if (hit) {
            const newDrawn = [...drawn, ...milestones.filter(m => hp <= m && !drawn.includes(m))];
            const card = newMDeck.pop();
            if (card) {
              hand.push(card);
              return { drawn: newDrawn, drewName: card.name };
            }
            return { drawn: newDrawn, drewName: null };
          }
          return { drawn, drewName: null };
        };

        if (redHP < gameState.red.health) {
          const res = drawMiracle(redHP, redDrawn, redHand);
          redDrawn = res.drawn;
          if (res.drewName) logs.push(`çº¢æ–¹è¡€é‡é™è‡³ ${redHP}ï¼ŒæŠ½å–å¥‡è¿¹ç‰Œï¼š${res.drewName}`);
        }
        if (blueHP < gameState.blue.health) {
          const res = drawMiracle(blueHP, blueDrawn, blueHand);
          blueDrawn = res.drawn;
          if (res.drewName) logs.push(`è“æ–¹è¡€é‡é™è‡³ ${blueHP}ï¼ŒæŠ½å–å¥‡è¿¹ç‰Œï¼š${res.drewName}`);
        }

        // åˆ¤èƒœ
        if (redHP <= 0 || blueHP <= 0) {
          const w = redHP > blueHP ? 'çº¢æ–¹' : (blueHP > redHP ? 'è“æ–¹' : 'å¹³å±€');
          logs.push(`ğŸ‰ ${w === 'å¹³å±€' ? 'å¹³å±€ï¼åŒæ–¹è¡€é‡ç›¸åŒ' : w + 'è·èƒœï¼å¯¹æ‰‹ç”Ÿå‘½å½’é›¶'}`);
          window.SoundManager.playSound('victory');
          setWinner(w);
        } else {
          logs.push('æˆ˜æ–—ç»“ç®—å®Œæˆ');
        }

        setGameState(prev => ({
          ...prev,
          phase: 'idle',
          red:  { ...prev.red,  battlefield: redBF,  health: redHP,  hand: redHand,  miracleDrawn: redDrawn },
          blue: { ...prev.blue, battlefield: blueBF, health: blueHP, hand: blueHand, miracleDrawn: blueDrawn },
          miracleDeck: newMDeck,
          discardPile: discard,
          log: [...prev.log, ...logs]
        }));

        // ç‰Œåº“è€—å°½æ£€æŸ¥ï¼ˆå»¶è¿Ÿä¸€å¸§ç¡®ä¿ state æ›´æ–°åå†åˆ¤ï¼‰
        setTimeout(() => {
          setGameState(prev => {
            if (prev.deck.length === 0 && prev.red.hand.length === 0 && prev.blue.hand.length === 0 && !winner) {
              const w = prev.red.health > prev.blue.health ? 'çº¢æ–¹' : (prev.blue.health > prev.red.health ? 'è“æ–¹' : 'å¹³å±€');
              setWinner(w);
              window.SoundManager.playSound('victory');
              return { ...prev, log: [...prev.log, '--- ç‰Œåº“è€—å°½ ---', `çº¢æ–¹:${prev.red.health} | è“æ–¹:${prev.blue.health}`, `${w === 'å¹³å±€' ? 'å¹³å±€' : w + 'è·èƒœ'}`] };
            }
            return prev;
          });
        }, 100);
      };

      // â”€â”€ é‡ç½® â”€â”€
      const reset = () => {
        setWinner(null);
        setGamePhase('notStarted');
        setBattleAnimation({ active: false, lane: -1 });
        initGame();
      };

      // â”€â”€ æ¸²æŸ“ â”€â”€
      if (!uiReady) return <div className="text-white text-center mt-40 text-xl">åŠ è½½ä¸­â€¦</div>;

      return (
        <GameUI
          gameState={gameState}
          gamePhase={gamePhase}
          allCards={allCards}
          winner={winner}
          battleAnimation={battleAnimation}
          cardShowOverlay={cardShowOverlay}
          onStartPicking={startPicking}
          onPickCard={pickCard}
          onStartTurn={startTurn}
          onSelectCard={selectCard}
          onPlayCard={playCard}
          onUseCardOnTarget={useCardOnTarget}
          onConfirmUse={confirmUse}
          onEndPhase={endPhase}
          onReset={reset}
          hideOpponentHand={false}
          myRole={null}
        />
      );
    };

    ReactDOM.render(<LocalGame />, document.getElementById('root'));
    </script>
</body>
</html>
