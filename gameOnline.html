<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å››è·¯çº¿å¡ç‰Œå¯¹æˆ˜ â€” åœ¨çº¿å¯¹æˆ˜</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.pubnub.com/sdk/javascript/pubnub.7.4.0.js"></script>
    <script src="shared.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
    const { useState, useEffect, useCallback, useRef } = React;

    const PUBNUB_CONFIG = {
        publishKey: 'demo',
        subscribeKey: 'demo',
    };

    const ROOMS = ['room1', 'room2', 'room3', 'room4', 'room5', 'room6'];

    const ReconnectManager = {
        STORAGE_KEY: 'cardgame_online_session',
        saveSession(data) {
            try {
                localStorage.setItem(this.STORAGE_KEY, JSON.stringify({
                    ...data,
                    timestamp: Date.now()
                }));
            } catch (e) {}
        },
        loadSession() {
            try {
                const data = localStorage.getItem(this.STORAGE_KEY);
                if (!data) return null;
                const session = JSON.parse(data);
                const age = Date.now() - session.timestamp;
                if (age > 30 * 60 * 1000) {
                    this.clearSession();
                    return null;
                }
                return session;
            } catch (e) {
                return null;
            }
        },
        clearSession() {
            localStorage.removeItem(this.STORAGE_KEY);
        }
    };

    class OnlineGameManager {
        constructor() {
            this.pubnub = null;
            this.roomId = null;
            this.playerId = null;
            this.playerSide = null;
            this.isReady = false;
            this.onMessageCallback = null;
            this.onPresenceCallback = null;
        }

        init(existingPlayerId = null) {
            this.playerId = existingPlayerId || 'p_' + Math.random().toString(36).substr(2, 9);
            this.pubnub = new PubNub({
                ...PUBNUB_CONFIG,
                uuid: this.playerId,
                heartbeatInterval: 10
            });
        }

        joinRoom(roomId) {
            this.roomId = roomId;
            this.subscribeToRoom();
            this.sendMessage({ type: 'player-join', playerId: this.playerId });
        }

        subscribeToRoom() {
            if (!this.pubnub || !this.roomId) return;
            this.pubnub.addListener({
                message: (event) => {
                    if (this.onMessageCallback) {
                        this.onMessageCallback(event.message);
                    }
                },
                presence: (event) => {
                    if (this.onPresenceCallback) {
                        this.onPresenceCallback(event);
                    }
                }
            });
            this.pubnub.subscribe({
                channels: [this.roomId],
                withPresence: true
            });
        }

        sendMessage(message) {
            if (!this.pubnub || !this.roomId) return;
            this.pubnub.publish({
                channel: this.roomId,
                message: {
                    ...message,
                    senderId: this.playerId,
                    timestamp: Date.now()
                }
            });
        }

        setReady(ready) {
            this.isReady = ready;
            this.sendMessage({ 
                type: 'player-ready', 
                playerId: this.playerId,
                ready: ready
            });
        }

        leaveRoom() {
            if (this.pubnub && this.roomId) {
                this.sendMessage({ type: 'player-leave', playerId: this.playerId });
                this.pubnub.unsubscribe({ channels: [this.roomId] });
            }
            this.roomId = null;
            this.playerSide = null;
            this.isReady = false;
        }

        setMessageCallback(callback) {
            this.onMessageCallback = callback;
        }

        setPresenceCallback(callback) {
            this.onPresenceCallback = callback;
        }
    }

    const OnlineGame = () => {
        const [uiReady, setUiReady] = useState(false);
        const [allCards, setAllCards] = useState([]);
        
        useEffect(() => { 
            window.GameUILoader.load().then(() => setUiReady(true)); 
            window.SoundManager.restoreFromStorage(); 
        }, []);

        useEffect(() => { 
            window.loadCards().then(cards => setAllCards(cards)).catch(err => { 
                console.error('åŠ è½½å¡ç‰Œå¤±è´¥', err); 
                alert('æ— æ³•åŠ è½½ card_data.csv'); 
            }); 
        }, []);

        const INIT_STATE = {
            turn: 0, phase: 'idle',
            red: { health: 30, coins: 0, hand: [], battlefield: [null,null,null,null], miracleDrawn: [30] },
            blue: { health: 30, coins: 0, hand: [], battlefield: [null,null,null,null], miracleDrawn: [30] },
            deck: [], miracleDeck: [], discardPile: [], initialCards: [], initialCardsBlue: [], selectedCard: null, log: []
        };

        const [screen, setScreen] = useState('lobby');
        const [currentRoomId, setCurrentRoomId] = useState(null);
        const gameManagerRef = useRef(null);
        const [roomPlayers, setRoomPlayers] = useState([]);
        const [showReconnectPrompt, setShowReconnectPrompt] = useState(false);
        const [reconnectData, setReconnectData] = useState(null);
        const [showRoulette, setShowRoulette] = useState(false);
        const [rouletteResult, setRouletteResult] = useState(null);
        const [gameState, setGameState] = useState(INIT_STATE);
        const gameStateRef = useRef(gameState);
        const [gamePhase, setGamePhase] = useState('notStarted');
        const [winner, setWinner] = useState(null);
        const [battleAnimation, setBattleAnimation] = useState({ active: false, lane: -1 });
        const [cardShowOverlay, setCardShowOverlay] = useState(null);

        useEffect(() => {
            gameStateRef.current = gameState;
        }, [gameState]);

        useEffect(() => {
            gameManagerRef.current = new OnlineGameManager();
            const session = ReconnectManager.loadSession();
            if (session && session.roomId) {
                setReconnectData(session);
                setShowReconnectPrompt(true);
            }
            return () => {
                if (gameManagerRef.current) {
                    gameManagerRef.current.leaveRoom();
                }
            };
        }, []);

        useEffect(() => {
            if (screen === 'game' && gameManagerRef.current) {
                ReconnectManager.saveSession({
                    roomId: currentRoomId,
                    playerId: gameManagerRef.current.playerId,
                    playerSide: gameManagerRef.current.playerSide,
                    gameState,
                    gamePhase,
                    screen
                });
            }
        }, [gameState, gamePhase, screen, currentRoomId]);

        const addLog = useCallback((msg) => { 
            setGameState(prev => ({ ...prev, log: [...prev.log, msg] })); 
        }, []);

        const showCardOverlay = useCallback((card) => {
            setCardShowOverlay(card);
            const dur = card.type === 'miracle' ? 2000 : 1000;
            window.SoundManager.playSound(card.type === 'miracle' ? 'miracle' : 'place');
            setTimeout(() => setCardShowOverlay(null), dur);
        }, []);

        const handleReconnect = () => {
            if (!reconnectData) return;
            gameManagerRef.current.init(reconnectData.playerId);
            gameManagerRef.current.playerSide = reconnectData.playerSide;
            gameManagerRef.current.joinRoom(reconnectData.roomId);
            setCurrentRoomId(reconnectData.roomId);
            setGameState(reconnectData.gameState || INIT_STATE);
            setGamePhase(reconnectData.gamePhase || 'notStarted');
            setScreen('game');
            setShowReconnectPrompt(false);
            gameManagerRef.current.sendMessage({ 
                type: 'player-reconnect',
                playerSide: reconnectData.playerSide
            });
            window.SoundManager.playSound('click');
        };

        const handleNewGame = () => {
            ReconnectManager.clearSession();
            setShowReconnectPrompt(false);
            window.SoundManager.playSound('click');
        };

        const handleNetworkMessage = useCallback((message) => {
            switch (message.type) {
                case 'player-join':
                    setRoomPlayers(prev => {
                        if (prev.find(p => p.playerId === message.playerId)) return prev;
                        return [...prev, { playerId: message.playerId, ready: false }];
                    });
                    window.SoundManager.playSound('click');

                    // ==================== ä¿®å¤å¼€å§‹ ====================
                    // å¦‚æœæ˜¯åˆ«äººåŠ å…¥äº†ï¼Œæˆ‘éœ€è¦å‘Šè¯‰ä»–â€œæˆ‘å·²ç»åœ¨æˆ¿é—´é‡Œäº†â€
                    // è¿™æ ·ååŠ å…¥çš„äººæ‰èƒ½çœ‹åˆ°å…ˆåŠ å…¥çš„äºº
                    if (message.playerId !== gameManagerRef.current.playerId) {
                        gameManagerRef.current.sendMessage({ 
                            type: 'player-exist', 
                            playerId: gameManagerRef.current.playerId,
                            ready: gameManagerRef.current.isReady // åŒæ­¥æˆ‘çš„å‡†å¤‡çŠ¶æ€
                        });
                    }
                    // ==================== ä¿®å¤ç»“æŸ ====================
                    break;

                // ==================== æ–°å¢ case ====================
                // å¤„ç†â€œè€ç©å®¶â€å‘æ¥çš„å­˜åœ¨å®£å‘Š
                case 'player-exist':
                    setRoomPlayers(prev => {
                        // å¦‚æœåˆ—è¡¨é‡Œå·²ç»æœ‰è¿™ä¸ªäººï¼Œåªæ›´æ–°çŠ¶æ€ï¼ˆé˜²æ­¢é‡å¤æ·»åŠ ï¼‰
                        if (prev.find(p => p.playerId === message.playerId)) {
                            return prev.map(p => 
                                p.playerId === message.playerId 
                                    ? { ...p, ready: message.ready } 
                                    : p
                            );
                        }
                        // å¦‚æœæ²¡æœ‰ï¼Œæ·»åŠ è¿›åˆ—è¡¨
                        return [...prev, { playerId: message.playerId, ready: message.ready }];
                    });
                    break;
                // ==================== æ–°å¢ç»“æŸ ====================

                case 'player-ready':
                    setRoomPlayers(prev => 
                        prev.map(p => 
                            p.playerId === message.playerId 
                                ? { ...p, ready: message.ready } 
                                : p
                        )
                    );
                    break;
                case 'player-leave':
                    setRoomPlayers(prev => prev.filter(p => p.playerId !== message.playerId));
                    if (screen === 'game') addLog('âš ï¸ å¯¹æ‰‹å·²ç¦»å¼€æˆ¿é—´');
                    break;
                case 'start-roulette':
                    if (message.senderId !== gameManagerRef.current.playerId) {
                        startRouletteAnimation(message.seed);
                    }
                    break;
                case 'roulette-result':
                    if (message.senderId !== gameManagerRef.current.playerId) {
                        applyRouletteResult(message.result);
                    }
                    break;
                case 'start-game':
                    if (message.senderId !== gameManagerRef.current.playerId) {
                        initializeGameWithSeed(message.seed);
                    }
                    break;
                case 'player-reconnect':
                    addLog(`${message.playerSide === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}å·²é‡æ–°è¿æ¥`);
                    break;
                case 'pick-card': handleRemotePickCard(message.card); break;
                case 'play-card': handleRemotePlayCard(message.card, message.laneIndex); break;
                case 'use-support': handleRemoteUseSupport(message.card, message.targetPlayer, message.laneIndex); break;
                case 'confirm-use': handleRemoteConfirmUse(message.card); break;
                case 'end-phase': handleRemoteEndPhase(); break;
                case 'start-turn': handleRemoteStartTurn(); break;
            }
        }, [screen, addLog]);

        useEffect(() => {
            if (!gameManagerRef.current) return;
            gameManagerRef.current.setMessageCallback(handleNetworkMessage);
            gameManagerRef.current.setPresenceCallback((event) => {
                if (event.action === 'timeout' || event.action === 'leave') {
                    if (event.uuid !== gameManagerRef.current.playerId) {
                        setRoomPlayers(prev => prev.filter(p => p.playerId !== event.uuid));
                        if (screen === 'game') addLog('âš ï¸ å¯¹æ‰‹æ–­çº¿');
                    }
                }
            });
        }, [handleNetworkMessage, screen, addLog]);

        const handleJoinRoom = (roomId) => {
            if (!gameManagerRef.current.pubnub) {
                gameManagerRef.current.init();
            }
            gameManagerRef.current.joinRoom(roomId);
            setCurrentRoomId(roomId);
            setScreen('room');
            setRoomPlayers([{ playerId: gameManagerRef.current.playerId, ready: false }]);
            window.SoundManager.playSound('click');
        };

        const handleToggleReady = () => {
            const newReady = !gameManagerRef.current.isReady;
            gameManagerRef.current.setReady(newReady);
            setRoomPlayers(prev => 
                prev.map(p => 
                    p.playerId === gameManagerRef.current.playerId 
                        ? { ...p, ready: newReady } 
                        : p
                )
            );
            window.SoundManager.playSound('click');
        };

        const handleLeaveRoom = () => {
            gameManagerRef.current.leaveRoom();
            setCurrentRoomId(null);
            setRoomPlayers([]);
            setScreen('lobby');
            window.SoundManager.playSound('click');
        };

        const handleBackToLobby = () => {
            if (confirm('ç¡®å®šè¦ç¦»å¼€æ¸¸æˆå—ï¼Ÿè¿›åº¦å°†ä¼šä¸¢å¤±ã€‚')) {
                gameManagerRef.current.leaveRoom();
                ReconnectManager.clearSession();
                setCurrentRoomId(null);
                setRoomPlayers([]);
                setGameState(INIT_STATE);
                setGamePhase('notStarted');
                setWinner(null);
                setScreen('lobby');
                window.SoundManager.playSound('click');
            }
        };

        const canStartGame = roomPlayers.length === 2 && roomPlayers.every(p => p.ready);

        // ==================== ä¿®å¤åçš„ useEffect ====================
        useEffect(() => {
            // åªæœ‰åœ¨æˆ¿é—´ç•Œé¢ä¸”åŒæ–¹å‡†å¤‡å¥½æ—¶æ‰è§¦å‘
            if (screen === 'room' && canStartGame) {
                // 1. ç¡®å®šè°æ˜¯â€œæˆ¿ä¸»â€ï¼ˆé€šè¿‡IDæ’åºï¼Œä¿è¯åŒæ–¹è®¤å®šä¸€è‡´ï¼‰
                // æˆ‘ä»¬çº¦å®šï¼šID å­—ç¬¦ä¸²æ’åºæ›´å°çš„é‚£ä¸ªæ˜¯æˆ¿ä¸»
                const sortedPlayers = [...roomPlayers].sort((a, b) => a.playerId.localeCompare(b.playerId));
                const isHost = sortedPlayers[0].playerId === gameManagerRef.current.playerId;

                // 2. åªæœ‰æˆ¿ä¸»è´Ÿè´£ç”Ÿæˆç§å­å¹¶å¹¿æ’­
                if (isHost) {
                    const seed = Date.now();
                    // å¹¿æ’­ç»™å¯¹æ–¹ï¼šâ€œå˜¿ï¼Œç”¨è¿™ä¸ªç§å­å¼€å§‹æŠ½ç­¾â€
                    gameManagerRef.current.sendMessage({ type: 'start-roulette', seed });
                    // è‡ªå·±åŒæ—¶ä¹Ÿå¼€å§‹åŠ¨ç”»
                    startRouletteAnimation(seed);
                    addLog('ğŸ² æˆ‘æ˜¯æˆ¿ä¸»ï¼Œæ­£åœ¨è¿›è¡ŒæŠ½ç­¾...');
                } else {
                    // éæˆ¿ä¸»ï¼ˆè®¿å®¢ï¼‰ä»€ä¹ˆéƒ½ä¸åšï¼Œç­‰å¾…ç½‘ç»œæ¶ˆæ¯è§¦å‘ startRouletteAnimation
                    addLog('â³ ç­‰å¾…æˆ¿ä¸»æŠ½ç­¾...');
                }
            }
        }, [canStartGame, screen, roomPlayers]); // æ³¨æ„ä¾èµ–é¡¹è¦æŠŠ roomPlayers åŠ è¿›å»
        // ==================== ä¿®å¤ç»“æŸ ====================

        const startRouletteAnimation = (seed) => {
            setShowRoulette(true);
            setScreen('roulette');
            window.SoundManager.playSound('spin');
            setTimeout(() => {
                const seededRandom = Math.sin(seed) * 10000;
                const randomValue = seededRandom - Math.floor(seededRandom);
                const players = [...roomPlayers].sort((a, b) => a.playerId.localeCompare(b.playerId));
                const result = randomValue > 0.5 ? 
                    { [players[0].playerId]: 'red', [players[1].playerId]: 'blue' } :
                    { [players[0].playerId]: 'blue', [players[1].playerId]: 'red' };
                gameManagerRef.current.sendMessage({ type: 'roulette-result', result });
                applyRouletteResult(result);
            }, 2000);
        };

        const applyRouletteResult = (result) => {
            const mySide = result[gameManagerRef.current.playerId];
            gameManagerRef.current.playerSide = mySide;
            setRouletteResult(mySide);
            addLog(`æŠ½ç­¾ç»“æœï¼šä½ æ˜¯${mySide === 'red' ? 'çº¢æ–¹ğŸ”´' : 'è“æ–¹ğŸ”µ'}`);
            setTimeout(() => {
                setShowRoulette(false);
                if (mySide === 'red') {
                    const gameSeed = Date.now();
                    gameManagerRef.current.sendMessage({ type: 'start-game', seed: gameSeed });
                    initializeGameWithSeed(gameSeed);
                }
            }, 1500);
        };

     const initializeGameWithSeed = (seed) => {
            if (!allCards || allCards.length === 0) return;
            const seededRandom = (s) => {
                const x = Math.sin(s++) * 10000;
                return x - Math.floor(x);
            };
            let currentSeed = seed;
            const seededShuffle = (arr) => {
                const a = [...arr];
                for (let i = a.length - 1; i > 0; i--) {
                    const j = Math.floor(seededRandom(currentSeed++) * (i + 1));
                    [a[i], a[j]] = [a[j], a[i]];
                }
                return a;
            };
            const regular = allCards.filter(c => c.type !== 'miracle');
            const miracles = allCards.filter(c => c.type === 'miracle');
            const deck = seededShuffle(regular.map(window.createCard));
            const miracleDeck = seededShuffle(miracles.map(window.createCard));
            
            const redSix = deck.slice(0, 6);
            const blueSix = deck.slice(6, 12);
            const rest = deck.slice(12);
            const mDeck = [...miracleDeck];
            const redM = mDeck.pop();
            const blueM = mDeck.pop();

            setGameState({
                ...INIT_STATE,
                red: { ...INIT_STATE.red, hand: redM ? [redM] : [] },
                blue: { ...INIT_STATE.blue, hand: blueM ? [blueM] : [] },
                deck: rest,
                miracleDeck: mDeck,
                // ã€ä¿®æ”¹ç‚¹ã€‘ï¼šç¡®ä¿é”®åä¸ UI æ¸²æŸ“æ—¶ä¸€è‡´
                redInitialPool: redSix,
                blueInitialPool: blueSix,
                log: [
                    'ğŸŒ åœ¨çº¿æ¸¸æˆå¼€å§‹ï¼',
                    `ä½ æ˜¯${gameManagerRef.current.playerSide === 'red' ? 'çº¢æ–¹ğŸ”´' : 'è“æ–¹ğŸ”µ'}`,
                    'åŒæ–¹å„æŠ½å–1å¼ å¥‡è¿¹ç‰Œ',
                    '--- é€‰ç‰Œé˜¶æ®µå¼€å§‹ ---'
                ]
            });
            setGamePhase('Picking');
            setScreen('game');
        };

        // æ¸¸æˆæ“ä½œå‡½æ•°ï¼ˆç®€åŒ–ç‰ˆï¼Œä¿ç•™æ ¸å¿ƒé€»è¾‘ï¼‰
       const pickCard = (card) => {
            if (gamePhase !== 'picking') return;
            const mySide = gameManagerRef.current.playerSide;
            window.SoundManager.playSound('click');
            
            // å‘é€ç»™å¯¹æ–¹
            gameManagerRef.current.sendMessage({ type: 'pick-card', card, side: mySide });

            setGameState(prev => {
                const poolKey = mySide === 'red' ? 'redInitialPool' : 'blueInitialPool';
                const newHand = [...prev[mySide].hand, card];
                const newPool = prev[poolKey].filter(c => c.instanceId !== card.instanceId);
                const isDone = newHand.length >= 4; // 1å¼ å¥‡è¿¹ + 3å¼ é€‰ç‰Œ

                return {
                    ...prev,
                    [mySide]: { ...prev[mySide], hand: newHand },
                    [poolKey]: isDone ? [] : newPool,
                    log: [...prev.log, `ä½ é€‰æ‹©äº† ${card.name}`]
                };
            });
        };

        const handleRemotePickCard = (message) => {
            const opponentSide = message.side;
            const card = message.card;

            setGameState(prev => {
                const poolKey = opponentSide === 'red' ? 'redInitialPool' : 'blueInitialPool';
                const newHand = [...prev[opponentSide].hand, card];
                const newPool = prev[poolKey].filter(c => c.instanceId !== card.instanceId);
                
                const isOpponentDone = newHand.length >= 4;
                const mySide = gameManagerRef.current.playerSide;
                const myPoolKey = mySide === 'red' ? 'redInitialPool' : 'blueInitialPool';
                const amIDone = prev[myPoolKey].length === 0;

                if (isOpponentDone && amIDone) {
                    setTimeout(() => setGamePhase('playing'), 500);
                }

                return {
                    ...prev,
                    [opponentSide]: { ...prev[opponentSide], hand: newHand },
                    [poolKey]: isOpponentDone ? [] : newPool,
                    log: [...prev.log, `${opponentSide === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}é€‰äº†ä¸€å¼ ç‰Œ`]
                };
            });
        
            } else if (phase === 'bluePicking') {
                setGameState(prev => {
                    const newHand = [...prev.blue.hand, card];
                    const remaining = prev.initialCards.filter(c => c.instanceId !== card.instanceId);
                    if (newHand.length === 3) {
                        setGamePhase('playing');
                        return {
                            ...prev,
                            blue: { ...prev.blue, hand: newHand },
                            initialCards: [],
                            deck: window.shuffleArray([...prev.deck, ...remaining]),
                            log: [...prev.log, 'è“æ–¹é€‰ç‰Œå®Œæˆ â†’ é€‰ç‰Œé˜¶æ®µç»“æŸ']
                        };
                    }
                    return {
                        ...prev,
                        blue: { ...prev.blue, hand: newHand },
                        initialCards: remaining,
                        log: [...prev.log, `è“æ–¹é€‰æ‹©äº† ${card.name}`]
                    };
                });
            }
        };

        const handleRemotePickCard = (card,side) => {
            const phase = gamePhase;
            const opponentSide = message.side;
    
    setGameState(prev => {
        const poolKey = opponentSide === 'red' ? 'redInitialPool' : 'blueInitialPool';
        const playerKey = opponentSide;
        
        const newHand = [...prev[playerKey].hand, message.card];
        const newPool = prev[poolKey].filter(c => c.instanceId !== message.card.instanceId);
        
        const isOpponentDone = newHand.length === 3;
        
        // å…³é”®ï¼šæ£€æŸ¥è‡ªå·±æ˜¯å¦ä¹Ÿé€‰å®Œäº†ï¼ˆé€šè¿‡åˆ¤æ–­æˆ‘æ–¹çš„æ± å­æ˜¯å¦ä¸ºç©ºï¼‰
        const mySide = gameManagerRef.current.playerSide;
        const myPoolKey = mySide === 'red' ? 'redInitialPool' : 'blueInitialPool';
        const amIDone = prev[myPoolKey].length === 0 && prev[mySide].hand.length >= 3;

        // å¦‚æœåŒæ–¹éƒ½é€‰å®Œäº†ï¼Œåˆ‡æ¢åˆ° playing é˜¶æ®µ
        if (isOpponentDone && amIDone) {
            setTimeout(() => setGamePhase('playing'), 500);
            return {
                ...prev,
                [playerKey]: { ...prev[playerKey], hand: newHand },
                [poolKey]: [],
                log: [...prev.log, 'åŒæ–¹é€‰ç‰Œå®Œæˆ â†’ æ¸¸æˆå¼€å§‹ï¼']
            };
        }

        return {
            ...prev,
            [playerKey]: { ...prev[playerKey], hand: newHand },
            [poolKey]: isOpponentDone ? [] : newPool
        };
    });

            } else if (phase === 'bluePicking') {
                setGameState(prev => {
                    const newHand = [...prev.blue.hand, card];
                    const remaining = prev.initialCards.filter(c => c.instanceId !== card.instanceId);
                    if (newHand.length === 3) {
                        setGamePhase('playing');
                        return {
                            ...prev,
                            blue: { ...prev.blue, hand: newHand },
                            initialCards: [],
                            deck: window.shuffleArray([...prev.deck, ...remaining]),
                            log: [...prev.log, 'è“æ–¹é€‰ç‰Œå®Œæˆ â†’ é€‰ç‰Œé˜¶æ®µç»“æŸ']
                        };
                    }
                    return {
                        ...prev,
                        blue: { ...prev.blue, hand: newHand },
                        initialCards: remaining,
                        log: [...prev.log, `è“æ–¹é€‰æ‹©äº† ${card.name}`]
                    };
                });
            }
        };

        const startTurn = () => {
            if (gameManagerRef.current.playerSide !== 'red') return;
            gameManagerRef.current.sendMessage({ type: 'start-turn' });
            doStartTurn();
        };

        const handleRemoteStartTurn = () => { doStartTurn(); };

        const doStartTurn = () => {
            setGameState(prev => {
                const newTurn = prev.turn + 1;
                const coins = Math.min(newTurn, 10);
                const logs = [`--- ç¬¬${newTurn}å›åˆå¼€å§‹ ---`, `åŒæ–¹è·å¾— ${coins} é‡‘å¸`];
                let deck = [...prev.deck];
                let redHand = [...prev.red.hand];
                let blueHand = [...prev.blue.hand];
                if (newTurn >= 2) {
                    for (let i = 0; i < 2; i++) {
                        const r = deck.pop();
                        if (r) redHand.push(r);
                        const b = deck.pop();
                        if (b) blueHand.push(b);
                    }
                    logs.push('åŒæ–¹å„æŠ½2å¼ ç‰Œ');
                } else {
                    logs.push('ç¬¬ä¸€å›åˆä¸æŠ½ç‰Œ');
                }
                return {
                    ...prev,
                    turn: newTurn,
                    phase: 'redDeploy',
                    deck,
                    red: { ...prev.red, coins, hand: redHand },
                    blue: { ...prev.blue, coins, hand: blueHand },
                    log: [...prev.log, ...logs]
                };
            });
        };

        const selectCard = (card, player) => {
            const phase = gameStateRef.current.phase;
            if (player !== gameManagerRef.current.playerSide || phase === 'idle' || phase === 'battle') return;
            const isRedPhase = phase === 'redDeploy' || phase === 'redSupport';
            if ((isRedPhase && player !== 'red') || (!isRedPhase && player !== 'blue')) return;
            setGameState(prev => {
                if (prev.selectedCard?.instanceId === card.instanceId) {
                    return { ...prev, selectedCard: null };
                }
                return { ...prev, selectedCard: card };
            });
        };

        const playCard = (laneIndex) => {
            const state = gameStateRef.current;
            const card = state.selectedCard;
            if (!card || card.type !== 'battlefield') return;
            const phase = state.phase;
            const player = (phase === 'redDeploy' || phase === 'redSupport') ? 'red' : 'blue';
            if (player !== gameManagerRef.current.playerSide) return;
            const playerState = state[player];
            if (playerState.coins < card.cost) {
                addLog('é‡‘å¸ä¸è¶³ï¼');
                return;
            }
            if (playerState.battlefield[laneIndex] !== null) {
                addLog('è¯¥è·¯çº¿å·²æœ‰å¡ç‰Œï¼');
                return;
            }
            window.SoundManager.playSound('place');
            gameManagerRef.current.sendMessage({ type: 'play-card', card, laneIndex });
            setGameState(prev => {
                const bf = [...prev[player].battlefield];
                bf[laneIndex] = { ...card };
                return {
                    ...prev,
                    [player]: {
                        ...prev[player],
                        battlefield: bf,
                        hand: prev[player].hand.filter(c => c.instanceId !== card.instanceId),
                        coins: prev[player].coins - card.cost
                    },
                    selectedCard: null,
                    log: [...prev.log, `${player === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}åœ¨è·¯çº¿${laneIndex+1}æ”¾ç½®äº† ${card.name}`]
                };
            });
        };

        const handleRemotePlayCard = (card, laneIndex) => {
            const state = gameStateRef.current;
            const phase = state.phase;
            const player = (phase === 'redDeploy' || phase === 'redSupport') ? 'red' : 'blue';
            if (player === gameManagerRef.current.playerSide) return;
            setGameState(prev => {
                const bf = [...prev[player].battlefield];
                bf[laneIndex] = { ...card };
                return {
                    ...prev,
                    [player]: {
                        ...prev[player],
                        battlefield: bf,
                        hand: prev[player].hand.filter(c => c.instanceId !== card.instanceId),
                        coins: prev[player].coins - card.cost
                    },
                    log: [...prev.log, `${player === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}åœ¨è·¯çº¿${laneIndex+1}æ”¾ç½®äº† ${card.name}`]
                };
            });
        };

        const useCardOnTarget = (targetPlayer, laneIndex) => {
            const state = gameStateRef.current;
            const card = state.selectedCard;
            if (!card || (card.type !== 'support' && card.type !== 'miracle')) return;
            const phase = state.phase;
            const player = (phase === 'redDeploy' || phase === 'redSupport') ? 'red' : 'blue';
            if (player !== gameManagerRef.current.playerSide) return;
            const playerState = state[player];
            const target = state[targetPlayer].battlefield[laneIndex];
            if (!target) {
                addLog('ç›®æ ‡ä½ç½®æ²¡æœ‰å•ä½ï¼');
                return;
            }
            const cost = card.type === 'miracle' ? 0 : card.cost;
            if (playerState.coins < cost) {
                addLog('é‡‘å¸ä¸è¶³ï¼');
                return;
            }
            addLog(`${player === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}å¯¹ ${target.name} ä½¿ç”¨äº† ${card.name}`);
            showCardOverlay(card);
            gameManagerRef.current.sendMessage({ type: 'use-support', card, targetPlayer, laneIndex });
            setGameState(prev => ({
                ...prev,
                [player]: {
                    ...playerState,
                    hand: playerState.hand.filter(c => c.instanceId !== card.instanceId),
                    coins: playerState.coins - cost
                },
                discardPile: [...prev.discardPile, card],
                selectedCard: null
            }));
        };

        const handleRemoteUseSupport = (card, targetPlayer, laneIndex) => {
            const state = gameStateRef.current;
            const phase = state.phase;
            const player = (phase === 'redDeploy' || phase === 'redSupport') ? 'red' : 'blue';
            if (player === gameManagerRef.current.playerSide) return;
            const playerState = state[player];
            const target = state[targetPlayer].battlefield[laneIndex];
            addLog(`${player === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}å¯¹ ${target?.name || 'ç›®æ ‡'} ä½¿ç”¨äº† ${card.name}`);
            showCardOverlay(card);
            setGameState(prev => ({
                ...prev,
                [player]: {
                    ...playerState,
                    hand: playerState.hand.filter(c => c.instanceId !== card.instanceId),
                    coins: playerState.coins - (card.type === 'miracle' ? 0 : card.cost)
                },
                discardPile: [...prev.discardPile, card]
            }));
        };

        const confirmUse = () => {
            const state = gameStateRef.current;
            const card = state.selectedCard;
            if (!card) return;
            const phase = state.phase;
            const player = (phase === 'redDeploy' || phase === 'redSupport') ? 'red' : 'blue';
            if (player !== gameManagerRef.current.playerSide) return;
            const playerState = state[player];
            const cost = card.type === 'miracle' ? 0 : card.cost;
            if (playerState.coins < cost) {
                addLog('é‡‘å¸ä¸è¶³ï¼');
                return;
            }
            addLog(`${player === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}ä½¿ç”¨äº† ${card.name}`);
            showCardOverlay(card);
            gameManagerRef.current.sendMessage({ type: 'confirm-use', card });
            setGameState(prev => ({
                ...prev,
                [player]: {
                    ...playerState,
                    hand: playerState.hand.filter(c => c.instanceId !== card.instanceId),
                    coins: playerState.coins - cost
                },
                discardPile: [...prev.discardPile, card],
                selectedCard: null
            }));
        };

        const handleRemoteConfirmUse = (card) => {
            const state = gameStateRef.current;
            const phase = state.phase;
            const player = (phase === 'redDeploy' || phase === 'redSupport') ? 'red' : 'blue';
            if (player === gameManagerRef.current.playerSide) return;
            const playerState = state[player];
            addLog(`${player === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}ä½¿ç”¨äº† ${card.name}`);
            showCardOverlay(card);
            setGameState(prev => ({
                ...prev,
                [player]: {
                    ...playerState,
                    hand: playerState.hand.filter(c => c.instanceId !== card.instanceId),
                    coins: playerState.coins - (card.type === 'miracle' ? 0 : card.cost)
                },
                discardPile: [...prev.discardPile, card]
            }));
        };

        const endPhase = () => {
            const phase = gameStateRef.current.phase;
            const player = (phase === 'redDeploy' || phase === 'redSupport') ? 'red' : 'blue';
            if (player !== gameManagerRef.current.playerSide) return;
            gameManagerRef.current.sendMessage({ type: 'end-phase' });
            doEndPhase();
        };

        const handleRemoteEndPhase = () => { doEndPhase(); };

        const doEndPhase = () => {
            const phase = gameStateRef.current.phase;
            const next = {
                redDeploy: 'blueDeploy',
                blueDeploy: 'redSupport',
                redSupport: 'battle'
            };
            const target = next[phase];
            if (target === 'battle') {
                setGameState(prev => ({
                    ...prev,
                    phase: 'battle',
                    selectedCard: null,
                    log: [...prev.log, '--- æˆ˜æ–—é˜¶æ®µ ---']
                }));
                setTimeout(resolveBattle, 500);
            } else {
                const names = {
                    blueDeploy: 'è“æ–¹éƒ¨ç½²é˜¶æ®µ',
                    redSupport: 'çº¢æ–¹æ”¯æ´é˜¶æ®µ'
                };
                setGameState(prev => ({
                    ...prev,
                    phase: target,
                    selectedCard: null,
                    log: [...prev.log, `--- ${names[target]} ---`]
                }));
            }
        };

        const resolveBattle = async () => {
            const state = gameStateRef.current;
            let redBF = state.red.battlefield.map(c => c ? {...c} : null);
            let blueBF = state.blue.battlefield.map(c => c ? {...c} : null);
            let redHP = state.red.health;
            let blueHP = state.blue.health;
            let discard = [...state.discardPile];
            let logs = [];
            for (let i = 0; i < 4; i++) {
                setBattleAnimation({ active: true, lane: i });
                window.SoundManager.playSound('attack');
                await new Promise(r => setTimeout(r, 1000));
                const rc = redBF[i];
                const bc = blueBF[i];
                if (rc && bc) {
                    rc.hp -= bc.atk;
                    bc.hp -= rc.atk;
                    logs.push(`è·¯çº¿${i+1}: ${rc.name}(${rc.hp}HP) VS ${bc.name}(${bc.hp}HP)`);
                    if (rc.hp <= 0) {
                        discard.push(rc);
                        redBF[i] = null;
                        logs.push(`  çº¢æ–¹ ${rc.name} è¢«å‡»è´¥`);
                    }
                    if (bc.hp <= 0) {
                        discard.push(bc);
                        blueBF[i] = null;
                        logs.push(`  è“æ–¹ ${bc.name} è¢«å‡»è´¥`);
                    }
                } else if (rc) {
                    blueHP -= rc.atk;
                    logs.push(`è·¯çº¿${i+1}: ${rc.name} æ”»å‡»è“æ–¹ï¼Œé€ æˆ ${rc.atk} ä¼¤å®³`);
                } else if (bc) {
                    redHP -= bc.atk;
                    logs.push(`è·¯çº¿${i+1}: ${bc.name} æ”»å‡»çº¢æ–¹ï¼Œé€ æˆ ${bc.atk} ä¼¤å®³`);
                }
            }
            setBattleAnimation({ active: false, lane: -1 });
            let newMDeck = [...state.miracleDeck];
            let redHand = [...state.red.hand];
            let blueHand = [...state.blue.hand];
            let redDrawn = [...state.red.miracleDrawn];
            let blueDrawn = [...state.blue.miracleDrawn];
            const milestones = [25, 20, 15, 10, 5];
            const drawMiracle = (hp, drawn, hand) => {
                const hit = milestones.some(m => hp <= m && !drawn.includes(m));
                if (hit) {
                    const newDrawn = [...drawn, ...milestones.filter(m => hp <= m && !drawn.includes(m))];
                    const card = newMDeck.pop();
                    if (card) {
                        hand.push(card);
                        return { drawn: newDrawn, drewName: card.name };
                    }
                    return { drawn: newDrawn, drewName: null };
                }
                return { drawn, drewName: null };
            };
            if (redHP < state.red.health) {
                const res = drawMiracle(redHP, redDrawn, redHand);
                redDrawn = res.drawn;
                if (res.drewName) logs.push(`çº¢æ–¹è¡€é‡é™è‡³ ${redHP}ï¼ŒæŠ½å–å¥‡è¿¹ç‰Œï¼š${res.drewName}`);
            }
            if (blueHP < state.blue.health) {
                const res = drawMiracle(blueHP, blueDrawn, blueHand);
                blueDrawn = res.drawn;
                if (res.drewName) logs.push(`è“æ–¹è¡€é‡é™è‡³ ${blueHP}ï¼ŒæŠ½å–å¥‡è¿¹ç‰Œï¼š${res.drewName}`);
            }
            if (redHP <= 0 || blueHP <= 0) {
                const w = redHP > blueHP ? 'çº¢æ–¹' : (blueHP > redHP ? 'è“æ–¹' : 'å¹³å±€');
                logs.push(`ğŸ‰ ${w === 'å¹³å±€' ? 'å¹³å±€' : w + 'è·èƒœï¼'}`);
                window.SoundManager.playSound('victory');
                setWinner(w);
            } else {
                logs.push('æˆ˜æ–—ç»“ç®—å®Œæˆ');
            }
            setGameState(prev => ({
                ...prev,
                phase: 'idle',
                red: {
                    ...prev.red,
                    battlefield: redBF,
                    health: redHP,
                    hand: redHand,
                    miracleDrawn: redDrawn
                },
                blue: {
                    ...prev.blue,
                    battlefield: blueBF,
                    health: blueHP,
                    hand: blueHand,
                    miracleDrawn: blueDrawn
                },
                miracleDeck: newMDeck,
                discardPile: discard,
                log: [...prev.log, ...logs]
            }));
            setTimeout(() => {
                const currentState = gameStateRef.current;
                if (currentState.deck.length === 0 && currentState.red.hand.length === 0 && currentState.blue.hand.length === 0 && !winner) {
                    const w = currentState.red.health > currentState.blue.health ? 'çº¢æ–¹' : (currentState.blue.health > currentState.red.health ? 'è“æ–¹' : 'å¹³å±€');
                    setWinner(w);
                    window.SoundManager.playSound('victory');
                    setGameState(prev => ({
                        ...prev,
                        log: [...prev.log, 'ç‰Œåº“è€—å°½', `${w === 'å¹³å±€' ? 'å¹³å±€' : w + 'è·èƒœ'}`]
                    }));
                }
            }, 100);
        };

        const reset = () => {
            setWinner(null);
            setGamePhase('notStarted');
            setBattleAnimation({ active: false, lane: -1 });
            setGameState(INIT_STATE);
            gameManagerRef.current.isReady = false;
            setRoomPlayers(prev => prev.map(p => ({ ...p, ready: false })));
            setScreen('room');
        };

        if (!uiReady) {
            return <div className="text-white text-center mt-40 text-xl">åŠ è½½ä¸­â€¦</div>;
        }

        if (showReconnectPrompt) {
            return (
                <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-blue-900 flex items-center justify-center p-4">
                    <div className="max-w-md w-full bg-gray-800 rounded-2xl p-8 shadow-2xl border-2 border-yellow-500">
                        <div className="text-center mb-6">
                            <div className="text-6xl mb-4">ğŸ”„</div>
                            <h2 className="text-3xl font-bold text-white mb-2">æ£€æµ‹åˆ°æ–­çº¿</h2>
                            <p className="text-gray-300">å‘ç°æœªå®Œæˆçš„æ¸¸æˆ</p>
                        </div>
                        <div className="bg-gray-700 rounded-xl p-4 mb-6">
                            <div className="text-sm text-gray-300 mb-2">æˆ¿é—´</div>
                            <div className="text-2xl font-bold text-yellow-400 font-mono">
                                {reconnectData?.roomId}
                            </div>
                            <div className="text-sm text-gray-400 mt-2">
                                èº«ä»½: {reconnectData?.playerSide === 'red' ? 'çº¢æ–¹ğŸ”´' : 'è“æ–¹ğŸ”µ'}
                            </div>
                        </div>
                        <div className="grid gap-3">
                            <button onClick={handleReconnect} className="w-full py-4 bg-green-600 hover:bg-green-700 text-white rounded-xl font-bold text-lg transition-all">
                                é‡æ–°è¿æ¥
                            </button>
                            <button onClick={handleNewGame} className="w-full py-4 bg-gray-600 hover:bg-gray-700 text-white rounded-xl font-bold text-lg transition-all">
                                å¼€å§‹æ–°æ¸¸æˆ
                            </button>
                        </div>
                    </div>
                </div>
            );
        }

        if (screen === 'lobby') {
            return (
                <div className="min-h-screen bg-gradient-to-br from-slate-900 via-blue-900 to-purple-900 flex items-center justify-center p-4">
                    <div className="max-w-4xl w-full">
                        <div className="text-center mb-12">
                            <h1 className="text-6xl font-bold text-white mb-4 drop-shadow-lg">
                                ğŸŒ åœ¨çº¿å¯¹æˆ˜å¤§å…
                            </h1>
                            <p className="text-xl text-gray-300">é€‰æ‹©ä¸€ä¸ªæˆ¿é—´å¼€å§‹æ¸¸æˆ</p>
                        </div>
                        <div className="grid grid-cols-2 md:grid-cols-3 gap-4 mb-8">
                            {ROOMS.map(roomId => (
                                <button
                                    key={roomId}
                                    onClick={() => handleJoinRoom(roomId)}
                                    onMouseEnter={() => window.SoundManager.playSound('hover')}
                                    className="bg-gradient-to-br from-purple-600 to-blue-600 rounded-xl p-6 text-white hover:scale-105 transition-all duration-200 shadow-lg"
                                >
                                    <div className="text-4xl mb-2">ğŸšª</div>
                                    <div className="text-2xl font-bold mb-1">{roomId.toUpperCase()}</div>
                                    <div className="text-sm text-gray-200">ç‚¹å‡»åŠ å…¥</div>
                                </button>
                            ))}
                        </div>
                        <div className="text-center">
                            <button onClick={() => { window.SoundManager.playSound('click'); window.location.href = 'index.html'; }} className="px-8 py-4 bg-gray-700 hover:bg-gray-600 text-white rounded-xl font-bold text-xl transition-all">
                                è¿”å›ä¸»ç•Œé¢
                            </button>
                        </div>
                        <div className="mt-8 text-center text-gray-400 text-sm">
                            <p>ğŸ’¡ é€‰æ‹©æˆ¿é—´åç­‰å¾…å¯¹æ‰‹ï¼ŒåŒæ–¹å‡†å¤‡å³å¯å¼€å§‹</p>
                            <p className="mt-2">ğŸ”„ æ”¯æŒæ–­çº¿é‡è¿</p>
                        </div>
                    </div>
                </div>
            );
        }

        if (screen === 'room') {
            const myPlayer = roomPlayers.find(p => p.playerId === gameManagerRef.current.playerId);
            const opponentPlayer = roomPlayers.find(p => p.playerId !== gameManagerRef.current.playerId);
            return (
                <div className="min-h-screen bg-gradient-to-br from-slate-900 via-blue-900 to-purple-900 flex items-center justify-center p-4">
                    <div className="max-w-2xl w-full">
                        <div className="bg-gray-800 rounded-2xl p-8 shadow-2xl">
                            <div className="text-center mb-8">
                                <h2 className="text-4xl font-bold text-white mb-2">
                                    å‡†å¤‡å®¤ - {currentRoomId?.toUpperCase()}
                                </h2>
                                <p className="text-gray-300">ç­‰å¾…ç©å®¶å‡†å¤‡</p>
                            </div>
                            <div className="grid grid-cols-2 gap-4 mb-8">
                                <div className={`border-2 rounded-xl p-6 text-center ${myPlayer?.ready ? 'bg-green-900/30 border-green-500' : 'bg-gray-700/30 border-gray-500'}`}>
                                    <div className="text-2xl mb-2">ğŸ‘¤</div>
                                    <div className="text-white font-bold mb-1">ä½ </div>
                                    <div className={`text-sm ${myPlayer?.ready ? 'text-green-400' : 'text-yellow-400'}`}>
                                        {myPlayer?.ready ? 'âœ“ å·²å‡†å¤‡' : 'æœªå‡†å¤‡'}
                                    </div>
                                </div>
                                <div className={`border-2 rounded-xl p-6 text-center ${opponentPlayer?.ready ? 'bg-green-900/30 border-green-500' : 'bg-gray-700/30 border-gray-500'}`}>
                                    <div className="text-2xl mb-2">{opponentPlayer ? 'ğŸ‘¤' : 'â³'}</div>
                                    <div className="text-white font-bold mb-1">{opponentPlayer ? 'å¯¹æ‰‹' : 'ç­‰å¾…ä¸­...'}</div>
                                    <div className={`text-sm ${opponentPlayer?.ready ? 'text-green-400' : 'text-yellow-400'}`}>
                                        {opponentPlayer ? (opponentPlayer.ready ? 'âœ“ å·²å‡†å¤‡' : 'æœªå‡†å¤‡') : 'ç­‰å¾…åŠ å…¥'}
                                    </div>
                                </div>
                            </div>
                            <div className="flex gap-4">
                                <button onClick={handleToggleReady} disabled={!opponentPlayer} className={`flex-1 py-4 rounded-xl font-bold text-xl transition-all ${!opponentPlayer ? 'bg-gray-600 text-gray-400 cursor-not-allowed' : (myPlayer?.ready ? 'bg-yellow-600 hover:bg-yellow-700 text-white' : 'bg-green-600 hover:bg-green-700 text-white')}`}>
                                    {myPlayer?.ready ? 'å–æ¶ˆå‡†å¤‡' : 'å‡†å¤‡'}
                                </button>
                                <button onClick={handleLeaveRoom} className="px-8 py-4 bg-red-600 hover:bg-red-700 text-white rounded-xl font-bold text-xl transition-all">
                                    ç¦»å¼€
                                </button>
                            </div>
                            {canStartGame && (
                                <div className="mt-6 text-center">
                                    <div className="inline-block px-6 py-3 bg-green-600 rounded-lg animate-pulse">
                                        <span className="text-white font-bold">åŒæ–¹å·²å‡†å¤‡ï¼Œå³å°†å¼€å§‹æŠ½ç­¾...</span>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        }

        if (screen === 'roulette' && showRoulette) {
            return (
                <div className="fixed inset-0 bg-black bg-opacity-90 z-[200] flex items-center justify-center">
                    <div className="text-center">
                        <h1 className="text-4xl font-bold text-white mb-8">çº¢è“æŠ½ç­¾ä¸­...</h1>
                        <div className="relative w-64 h-64 mx-auto">
                            <div className="absolute inset-0 rounded-full border-8 border-gray-700 overflow-hidden animate-spin" style={{ animationDuration: '0.5s' }}>
                                <div className="absolute top-0 left-0 w-full h-1/2 bg-red-600"></div>
                                <div className="absolute bottom-0 left-0 w-full h-1/2 bg-blue-600"></div>
                            </div>
                            <div className="absolute inset-0 flex items-center justify-center">
                                <div className="w-4 h-20 bg-yellow-400 rounded-full shadow-2xl" style={{ transform: 'translateY(-60px)' }}></div>
                            </div>
                        </div>
                        {rouletteResult && (
                            <div className="mt-8 text-3xl font-bold animate-pulse text-white">
                                {rouletteResult === 'red' ? 'ğŸ”´ ä½ æ˜¯çº¢æ–¹ï¼' : 'ğŸ”µ ä½ æ˜¯è“æ–¹ï¼'}
                            </div>
                        )}
                    </div>
                </div>
            );
        }

      if (screen === 'game') {
    if (!window.GameUI) {
        return <div className="text-white text-center mt-40 text-xl">æ¸¸æˆUIæœªåŠ è½½â€¦</div>;
    }

    const mySide = gameManagerRef.current?.playerSide;

    // é˜²æ­¢ gameState ä¸ºç©º
    if (!gameState) return null;

    const displayGameState = {
        ...gameState,
        initialCards:
            mySide === 'red'
                ? gameState.redInitialPool
                : gameState.blueInitialPool
    };

    const opponentOnline = roomPlayers.length === 2;

    return (
        <window.GameUI
            gameState={displayGameState}
            gamePhase={gamePhase}
            allCards={allCards}
            winner={winner}
            battleAnimation={battleAnimation}
            cardShowOverlay={cardShowOverlay}
            onStartPicking={() => {}}
            onPickCard={pickCard}
            onStartTurn={startTurn}
            onSelectCard={selectCard}
            onPlayCard={playCard}
            onUseCardOnTarget={useCardOnTarget}
            onConfirmUse={confirmUse}
            onEndPhase={endPhase}
            onReset={reset}
            hideOpponentHand={true}
            myRole={mySide}
            extraUI={
                <div className="fixed top-4 right-4 z-50 bg-gray-800 rounded-lg p-3 shadow-lg border-2 border-purple-500">
                    <div className="text-white text-sm">
                        <div className="font-bold mb-1">ğŸŒ åœ¨çº¿å¯¹æˆ˜</div>
                        <div className="text-yellow-400 font-mono text-xs">
                            æˆ¿é—´: {currentRoomId?.toUpperCase()}
                        </div>
                        <div
                            className={`text-xs mt-1 flex items-center gap-1 ${
                                opponentOnline ? 'text-green-400' : 'text-red-400'
                            }`}
                        >
                            <div
                                className={`w-2 h-2 rounded-full ${
                                    opponentOnline
                                        ? 'bg-green-500 animate-pulse'
                                        : 'bg-red-500'
                                }`}
                            ></div>
                            {opponentOnline ? 'å¯¹æ‰‹åœ¨çº¿' : 'å¯¹æ‰‹ç¦»çº¿'}
                        </div>
                        <button
                            onClick={handleBackToLobby}
                            className="mt-2 w-full px-2 py-1 bg-red-600 hover:bg-red-700 rounded text-xs transition-all"
                        >
                            é€€å‡ºæ¸¸æˆ
                        </button>
                    </div>
                </div>
            }
        />
    );
}

        return null; // ç¡®ä¿åœ¨ç»„ä»¶å†…éƒ¨ï¼Œä¸”æ˜¯æ‰€æœ‰ screen åˆ¤æ–­ä¹‹åçš„å…œåº•è¿”å›
    }; // è¿™é‡Œæ‰æ˜¯ OnlineGame ç»„ä»¶çš„ç»“æŸ

    ReactDOM.render(<OnlineGame />, document.getElementById('root'));
    </script>
