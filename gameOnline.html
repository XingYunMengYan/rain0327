<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å››è·¯çº¿å¡ç‰Œå¯¹æˆ˜ â€” åœ¨çº¿å¯¹æˆ˜</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.pubnub.com/sdk/javascript/pubnub.7.4.0.js"></script>
    <script src="shared.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
    const { useState, useEffect, useCallback, useRef } = React;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PubNub é…ç½®
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const PUBNUB_CONFIG = {
        publishKey: 'pub-c-f4e44d70-cc7d-4f6b-a8f3-cf3a93b39a0a',
        subscribeKey: 'sub-c-c4597e4a-cee9-4265-b2d7-136bb547facb',
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // åœ¨çº¿æ¸¸æˆç®¡ç†å™¨
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    class OnlineGameManager {
        constructor() {
            this.pubnub = null;
            this.roomId = null;
            this.playerId = null;
            this.playerSide = null;
            this.isHost = false;
            this.onMessageCallback = null;
            this.onPresenceCallback = null;
        }

        init() {
            this.playerId = 'player_' + Math.random().toString(36).substr(2, 9);
            this.pubnub = new PubNub({
                ...PUBNUB_CONFIG,
                uuid: this.playerId,
            });
        }

        createRoom() {
            this.roomId = this.generateRoomId();
            this.isHost = true;
            this.playerSide = 'red';
            this.subscribeToRoom();
            return this.roomId;
        }

        joinRoom(roomId) {
            this.roomId = roomId;
            this.isHost = false;
            this.playerSide = 'blue';
            this.subscribeToRoom();
            this.sendMessage({ type: 'player-joined', playerId: this.playerId });
        }

        subscribeToRoom() {
            if (!this.pubnub || !this.roomId) return;

            this.pubnub.addListener({
                message: (event) => {
                    if (event.message.senderId !== this.playerId && this.onMessageCallback) {
                        this.onMessageCallback(event.message);
                    }
                },
                presence: (event) => {
                    if (this.onPresenceCallback) {
                        this.onPresenceCallback(event);
                    }
                }
            });

            this.pubnub.subscribe({
                channels: [this.roomId],
                withPresence: true
            });
        }

        sendMessage(message) {
            if (!this.pubnub || !this.roomId) return;
            
            this.pubnub.publish({
                channel: this.roomId,
                message: {
                    ...message,
                    senderId: this.playerId,
                    timestamp: Date.now()
                }
            });
        }

        leaveRoom() {
            if (this.pubnub && this.roomId) {
                this.pubnub.unsubscribe({
                    channels: [this.roomId]
                });
            }
        }

        generateRoomId() {
            return Math.random().toString(36).substr(2, 6).toUpperCase();
        }

        setMessageCallback(callback) {
            this.onMessageCallback = callback;
        }

        setPresenceCallback(callback) {
            this.onPresenceCallback = callback;
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ä¸»åº”ç”¨ç»„ä»¶
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const OnlineGame = () => {
        const [uiReady, setUiReady] = useState(false);
        useEffect(() => { 
            window.GameUILoader.load().then(() => setUiReady(true)); 
            window.SoundManager.restoreFromStorage(); 
        }, []);

        const [allCards, setAllCards] = useState([]);
        useEffect(() => { 
            window.loadCards().then(cards => setAllCards(cards)).catch(err => { 
                console.error('åŠ è½½å¡ç‰Œå¤±è´¥', err); 
                alert('æ— æ³•åŠ è½½ card_data.csv'); 
            }); 
        }, []);

        const INIT_STATE = {
            turn: 0, phase: 'idle',
            red:  { health: 30, coins: 0, hand: [], battlefield: [null,null,null,null], miracleDrawn: [30] },
            blue: { health: 30, coins: 0, hand: [], battlefield: [null,null,null,null], miracleDrawn: [30] },
            deck: [], miracleDeck: [], discardPile: [], initialCards: [], initialCardsBlue: [], selectedCard: null, log: []
        };

        // ç½‘ç»œçŠ¶æ€
        const [screen, setScreen] = useState('menu');
        const [roomId, setRoomId] = useState('');
        const [roomInput, setRoomInput] = useState('');
        const [gameManager] = useState(() => new OnlineGameManager());
        const [opponentConnected, setOpponentConnected] = useState(false);

        // æ¸¸æˆçŠ¶æ€
        const [gameState, setGameState] = useState(INIT_STATE);
        const [gamePhase, setGamePhase] = useState('notStarted');
        const [winner, setWinner] = useState(null);
        const [battleAnimation, setBattleAnimation] = useState({ active: false, lane: -1 });
        const [cardShowOverlay, setCardShowOverlay] = useState(null);

        const addLog = useCallback((msg) => { 
            setGameState(prev => ({ ...prev, log: [...prev.log, msg] })); 
        }, []);

        const showCardOverlay = useCallback((card) => {
            setCardShowOverlay(card);
            const dur = card.type === 'miracle' ? 2000 : 1000;
            window.SoundManager.playSound(card.type === 'miracle' ? 'miracle' : 'place');
            setTimeout(() => setCardShowOverlay(null), dur);
        }, []);

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // ç½‘ç»œæ¶ˆæ¯å¤„ç†
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        useEffect(() => {
            gameManager.init();
            return () => {
                gameManager.leaveRoom();
            };
        }, []);

        useEffect(() => {
            gameManager.setMessageCallback((message) => {
                handleNetworkMessage(message);
            });

            gameManager.setPresenceCallback((event) => {
                if (event.action === 'join' && event.uuid !== gameManager.playerId) {
                    setOpponentConnected(true);
                    window.SoundManager.playSound('click');
                }
                if (event.action === 'leave') {
                    setOpponentConnected(false);
                    addLog('âš ï¸ å¯¹æ‰‹å·²ç¦»å¼€æˆ¿é—´');
                }
            });
        }, [screen, gameState, gamePhase]);

        const handleNetworkMessage = useCallback((message) => {
            console.log('æ”¶åˆ°æ¶ˆæ¯:', message.type, message);

            switch (message.type) {
                case 'player-joined':
                    setOpponentConnected(true);
                    window.SoundManager.playSound('click');
                    break;
                
                case 'start-game':
                    if (!gameManager.isHost) {
                        initializeGame(message.seed);
                    }
                    break;
                
                case 'pick-card':
                    handleRemotePickCard(message.card);
                    break;

                case 'play-card':
                    handleRemotePlayCard(message.card, message.laneIndex);
                    break;

                case 'use-support':
                    handleRemoteUseSupport(message.card, message.targetPlayer, message.laneIndex);
                    break;

                case 'confirm-use':
                    handleRemoteConfirmUse(message.card);
                    break;

                case 'end-phase':
                    handleRemoteEndPhase();
                    break;

                case 'start-turn':
                    handleRemoteStartTurn();
                    break;
            }
        }, [gameState, gamePhase, gameManager.isHost]);

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // æˆ¿é—´ç®¡ç†
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const handleCreateRoom = () => {
            const newRoomId = gameManager.createRoom();
            setRoomId(newRoomId);
            setScreen('lobby');
            window.SoundManager.playSound('click');
        };

        const handleJoinRoom = () => {
            if (!roomInput.trim()) {
                alert('è¯·è¾“å…¥æˆ¿é—´å·ï¼');
                return;
            }
            gameManager.joinRoom(roomInput.toUpperCase());
            setRoomId(roomInput.toUpperCase());
            setScreen('lobby');
            window.SoundManager.playSound('click');
        };

        const handleStartGame = () => {
            if (!opponentConnected) {
                alert('ç­‰å¾…å¯¹æ‰‹åŠ å…¥æˆ¿é—´ï¼');
                return;
            }
            
            const seed = Date.now();
            initializeGame(seed);
            gameManager.sendMessage({ type: 'start-game', seed });
            window.SoundManager.playSound('click');
        };

        const handleBackToLobby = () => {
            gameManager.leaveRoom();
            setScreen('menu');
            setRoomId('');
            setOpponentConnected(false);
            setGameState(INIT_STATE);
            setGamePhase('notStarted');
            setWinner(null);
            window.SoundManager.playSound('click');
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // æ¸¸æˆåˆå§‹åŒ–
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const initializeGame = (seed) => {
            if (!allCards.length) return;

            const seededRandom = (s) => {
                const x = Math.sin(s++) * 10000;
                return x - Math.floor(x);
            };

            let currentSeed = seed;
            const seededShuffle = (arr) => {
                const a = [...arr];
                for (let i = a.length - 1; i > 0; i--) {
                    const j = Math.floor(seededRandom(currentSeed++) * (i + 1));
                    [a[i], a[j]] = [a[j], a[i]];
                }
                return a;
            };

            const regular = allCards.filter(c => c.type !== 'miracle');
            const miracles = allCards.filter(c => c.type === 'miracle');
            const deck = seededShuffle(regular.map(window.createCard));
            const miracleDeck = seededShuffle(miracles.map(window.createCard));

            const redSix = deck.slice(0, 6);
            const blueSix = deck.slice(6, 12);
            const rest = deck.slice(12);

            const mDeck = [...miracleDeck];
            const redM = mDeck.pop();
            const blueM = mDeck.pop();

            setGameState({
                ...INIT_STATE,
                red: { ...INIT_STATE.red, hand: redM ? [redM] : [] },
                blue: { ...INIT_STATE.blue, hand: blueM ? [blueM] : [] },
                deck: rest,
                miracleDeck: mDeck,
                initialCards: redSix,
                initialCardsBlue: blueSix,
                log: [
                    'ğŸŒ åœ¨çº¿æ¸¸æˆå¼€å§‹ï¼',
                    `ä½ æ˜¯${gameManager.playerSide === 'red' ? 'çº¢æ–¹ğŸ”´' : 'è“æ–¹ğŸ”µ'}`,
                    'åŒæ–¹å„æŠ½å–1å¼ å¥‡è¿¹ç‰Œ',
                    '--- é€‰ç‰Œé˜¶æ®µå¼€å§‹ ---'
                ]
            });
            setGamePhase('redPicking');
            setScreen('game');
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // æ¸¸æˆæ“ä½œï¼ˆä¿ç•™æ ¸å¿ƒé€»è¾‘ï¼Œç¯‡å¹…é™åˆ¶çœç•¥éƒ¨åˆ†ä»£ç ï¼‰
        // å®Œæ•´ä»£ç è¯·å‚è€ƒä¸Šé¢çš„ç‰ˆæœ¬
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        const pickCard = (card) => {
            const isMyTurn = (gamePhase === 'redPicking' && gameManager.playerSide === 'red') || 
                            (gamePhase === 'bluePicking' && gameManager.playerSide === 'blue');
            if (!isMyTurn) return;

            window.SoundManager.playSound('click');
            gameManager.sendMessage({ type: 'pick-card', card });

            if (gamePhase === 'redPicking') {
                const newHand = [...gameState.red.hand, card];
                const remaining = gameState.initialCards.filter(c => c.instanceId !== card.instanceId);
                if (newHand.length === 3) {
                    setGameState(prev => ({
                        ...prev,
                        red: { ...prev.red, hand: newHand },
                        initialCards: prev.initialCardsBlue,
                        deck: window.shuffleArray([...prev.deck, ...remaining]),
                        log: [...prev.log, 'çº¢æ–¹é€‰ç‰Œå®Œæˆ']
                    }));
                    setGamePhase('bluePicking');
                } else {
                    setGameState(prev => ({
                        ...prev,
                        red: { ...prev.red, hand: newHand },
                        initialCards: remaining,
                        log: [...prev.log, `çº¢æ–¹é€‰æ‹©äº† ${card.name}`]
                    }));
                }
            } else if (gamePhase === 'bluePicking') {
                const newHand = [...gameState.blue.hand, card];
                const remaining = gameState.initialCards.filter(c => c.instanceId !== card.instanceId);
                if (newHand.length === 3) {
                    setGameState(prev => ({
                        ...prev,
                        blue: { ...prev.blue, hand: newHand },
                        initialCards: [],
                        deck: window.shuffleArray([...prev.deck, ...remaining]),
                        log: [...prev.log, 'è“æ–¹é€‰ç‰Œå®Œæˆ â†’ é€‰ç‰Œé˜¶æ®µç»“æŸ']
                    }));
                    setGamePhase('playing');
                } else {
                    setGameState(prev => ({
                        ...prev,
                        blue: { ...prev.blue, hand: newHand },
                        initialCards: remaining,
                        log: [...prev.log, `è“æ–¹é€‰æ‹©äº† ${card.name}`]
                    }));
                }
            }
        };

        const handleRemotePickCard = (card) => {
            const opponentSide = gameManager.playerSide === 'red' ? 'blue' : 'red';
            const isOpponentTurn = (gamePhase === 'redPicking' && opponentSide === 'red') || 
                                  (gamePhase === 'bluePicking' && opponentSide === 'blue');
            if (!isOpponentTurn) return;

            if (gamePhase === 'redPicking') {
                const newHand = [...gameState.red.hand, card];
                const remaining = gameState.initialCards.filter(c => c.instanceId !== card.instanceId);
                if (newHand.length === 3) {
                    setGameState(prev => ({
                        ...prev,
                        red: { ...prev.red, hand: newHand },
                        initialCards: prev.initialCardsBlue,
                        deck: window.shuffleArray([...prev.deck, ...remaining]),
                        log: [...prev.log, 'çº¢æ–¹é€‰ç‰Œå®Œæˆ']
                    }));
                    setGamePhase('bluePicking');
                } else {
                    setGameState(prev => ({
                        ...prev,
                        red: { ...prev.red, hand: newHand },
                        initialCards: remaining,
                        log: [...prev.log, `çº¢æ–¹é€‰æ‹©äº† ${card.name}`]
                    }));
                }
            } else if (gamePhase === 'bluePicking') {
                const newHand = [...gameState.blue.hand, card];
                const remaining = gameState.initialCards.filter(c => c.instanceId !== card.instanceId);
                if (newHand.length === 3) {
                    setGameState(prev => ({
                        ...prev,
                        blue: { ...prev.blue, hand: newHand },
                        initialCards: [],
                        deck: window.shuffleArray([...prev.deck, ...remaining]),
                        log: [...prev.log, 'è“æ–¹é€‰ç‰Œå®Œæˆ â†’ é€‰ç‰Œé˜¶æ®µç»“æŸ']
                    }));
                    setGamePhase('playing');
                } else {
                    setGameState(prev => ({
                        ...prev,
                        blue: { ...prev.blue, hand: newHand },
                        initialCards: remaining,
                        log: [...prev.log, `è“æ–¹é€‰æ‹©äº† ${card.name}`]
                    }));
                }
            }
        };

        // ç”±äºç¯‡å¹…é™åˆ¶ï¼Œä»¥ä¸‹å‡½æ•°çœç•¥å…·ä½“å®ç°ï¼Œè¯·å‚è€ƒå®Œæ•´ç‰ˆæœ¬
        const startTurn = () => {
            if (gameManager.playerSide !== 'red') return;
            gameManager.sendMessage({ type: 'start-turn' });
            handleRemoteStartTurn();
        };

        const handleRemoteStartTurn = () => {
            const newTurn = gameState.turn + 1;
            const coins = Math.min(newTurn, 10);
            const logs = [`--- ç¬¬${newTurn}å›åˆå¼€å§‹ ---`, `åŒæ–¹è·å¾— ${coins} é‡‘å¸`];
            
            let deck = [...gameState.deck];
            let redHand = [...gameState.red.hand];
            let blueHand = [...gameState.blue.hand];

            if (newTurn >= 2) {
                for (let i = 0; i < 2; i++) {
                    const r = deck.pop();
                    if (r) redHand.push(r);
                    const b = deck.pop();
                    if (b) blueHand.push(b);
                }
                logs.push('åŒæ–¹å„æŠ½2å¼ ç‰Œ');
            } else {
                logs.push('ç¬¬ä¸€å›åˆä¸æŠ½ç‰Œ');
            }

            setGameState(prev => ({
                ...prev,
                turn: newTurn,
                phase: 'redDeploy',
                deck,
                red: { ...prev.red, coins, hand: redHand },
                blue: { ...prev.blue, coins, hand: blueHand },
                log: [...prev.log, ...logs]
            }));
        };

        const selectCard = (card, player) => {
            if (player !== gameManager.playerSide || gameState.phase === 'idle' || gameState.phase === 'battle') return;
            const isRedPhase = gameState.phase === 'redDeploy' || gameState.phase === 'redSupport';
            if ((isRedPhase && player !== 'red') || (!isRedPhase && player !== 'blue')) return;
            
            if (gameState.selectedCard?.instanceId === card.instanceId) {
                setGameState(prev => ({ ...prev, selectedCard: null }));
                return;
            }
            setGameState(prev => ({ ...prev, selectedCard: card }));
        };

        const playCard = (laneIndex) => {
            const card = gameState.selectedCard;
            if (!card || card.type !== 'battlefield') return;
            
            const player = (gameState.phase === 'redDeploy' || gameState.phase === 'redSupport') ? 'red' : 'blue';
            if (player !== gameManager.playerSide) return;

            const playerState = gameState[player];
            if (playerState.coins < card.cost) {
                addLog('é‡‘å¸ä¸è¶³ï¼');
                return;
            }
            if (playerState.battlefield[laneIndex] !== null) {
                addLog('è¯¥è·¯çº¿å·²æœ‰å¡ç‰Œï¼');
                return;
            }

            window.SoundManager.playSound('place');
            gameManager.sendMessage({ type: 'play-card', card, laneIndex });

            const bf = [...playerState.battlefield];
            bf[laneIndex] = { ...card };
            setGameState(prev => ({
                ...prev,
                [player]: {
                    ...playerState,
                    battlefield: bf,
                    hand: playerState.hand.filter(c => c.instanceId !== card.instanceId),
                    coins: playerState.coins - card.cost
                },
                selectedCard: null,
                log: [...prev.log, `${player === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}åœ¨è·¯çº¿${laneIndex+1}æ”¾ç½®äº† ${card.name}`]
            }));
        };

        const handleRemotePlayCard = (card, laneIndex) => {
            const player = (gameState.phase === 'redDeploy' || gameState.phase === 'redSupport') ? 'red' : 'blue';
            if (player === gameManager.playerSide) return;

            const playerState = gameState[player];
            const bf = [...playerState.battlefield];
            bf[laneIndex] = { ...card };
            
            setGameState(prev => ({
                ...prev,
                [player]: {
                    ...playerState,
                    battlefield: bf,
                    hand: playerState.hand.filter(c => c.instanceId !== card.instanceId),
                    coins: playerState.coins - card.cost
                },
                log: [...prev.log, `${player === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}åœ¨è·¯çº¿${laneIndex+1}æ”¾ç½®äº† ${card.name}`]
            }));
        };

        const useCardOnTarget = (targetPlayer, laneIndex) => {
            const card = gameState.selectedCard;
            if (!card || (card.type !== 'support' && card.type !== 'miracle')) return;
            
            const player = (gameState.phase === 'redDeploy' || gameState.phase === 'redSupport') ? 'red' : 'blue';
            if (player !== gameManager.playerSide) return;

            const playerState = gameState[player];
            const target = gameState[targetPlayer].battlefield[laneIndex];
            if (!target) {
                addLog('ç›®æ ‡ä½ç½®æ²¡æœ‰å•ä½ï¼');
                return;
            }

            const cost = card.type === 'miracle' ? 0 : card.cost;
            if (playerState.coins < cost) {
                addLog('é‡‘å¸ä¸è¶³ï¼');
                return;
            }

            addLog(`${player === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}å¯¹ ${target.name} ä½¿ç”¨äº† ${card.name}`);
            showCardOverlay(card);
            gameManager.sendMessage({ type: 'use-support', card, targetPlayer, laneIndex });

            setGameState(prev => ({
                ...prev,
                [player]: {
                    ...playerState,
                    hand: playerState.hand.filter(c => c.instanceId !== card.instanceId),
                    coins: playerState.coins - cost
                },
                discardPile: [...prev.discardPile, card],
                selectedCard: null
            }));
        };

        const handleRemoteUseSupport = (card, targetPlayer, laneIndex) => {
            const player = (gameState.phase === 'redDeploy' || gameState.phase === 'redSupport') ? 'red' : 'blue';
            if (player === gameManager.playerSide) return;

            const playerState = gameState[player];
            const target = gameState[targetPlayer].battlefield[laneIndex];
            
            addLog(`${player === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}å¯¹ ${target?.name || 'ç›®æ ‡'} ä½¿ç”¨äº† ${card.name}`);
            showCardOverlay(card);

            setGameState(prev => ({
                ...prev,
                [player]: {
                    ...playerState,
                    hand: playerState.hand.filter(c => c.instanceId !== card.instanceId),
                    coins: playerState.coins - (card.type === 'miracle' ? 0 : card.cost)
                },
                discardPile: [...prev.discardPile, card]
            }));
        };

        const confirmUse = () => {
            const card = gameState.selectedCard;
            if (!card) return;
            
            const player = (gameState.phase === 'redDeploy' || gameState.phase === 'redSupport') ? 'red' : 'blue';
            if (player !== gameManager.playerSide) return;

            const playerState = gameState[player];
            const cost = card.type === 'miracle' ? 0 : card.cost;
            if (playerState.coins < cost) {
                addLog('é‡‘å¸ä¸è¶³ï¼');
                return;
            }

            addLog(`${player === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}ä½¿ç”¨äº† ${card.name}`);
            showCardOverlay(card);
            gameManager.sendMessage({ type: 'confirm-use', card });

            setGameState(prev => ({
                ...prev,
                [player]: {
                    ...playerState,
                    hand: playerState.hand.filter(c => c.instanceId !== card.instanceId),
                    coins: playerState.coins - cost
                },
                discardPile: [...prev.discardPile, card],
                selectedCard: null
            }));
        };

        const handleRemoteConfirmUse = (card) => {
            const player = (gameState.phase === 'redDeploy' || gameState.phase === 'redSupport') ? 'red' : 'blue';
            if (player === gameManager.playerSide) return;

            const playerState = gameState[player];
            addLog(`${player === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}ä½¿ç”¨äº† ${card.name}`);
            showCardOverlay(card);

            setGameState(prev => ({
                ...prev,
                [player]: {
                    ...playerState,
                    hand: playerState.hand.filter(c => c.instanceId !== card.instanceId),
                    coins: playerState.coins - (card.type === 'miracle' ? 0 : card.cost)
                },
                discardPile: [...prev.discardPile, card]
            }));
        };

        const endPhase = () => {
            const player = (gameState.phase === 'redDeploy' || gameState.phase === 'redSupport') ? 'red' : 'blue';
            if (player !== gameManager.playerSide) return;

            gameManager.sendMessage({ type: 'end-phase' });
            handleRemoteEndPhase();
        };

        const handleRemoteEndPhase = () => {
            const next = {
                redDeploy: 'blueDeploy',
                blueDeploy: 'redSupport',
                redSupport: 'battle'
            };
            const target = next[gameState.phase];

            if (target === 'battle') {
                setGameState(prev => ({
                    ...prev,
                    phase: 'battle',
                    selectedCard: null,
                    log: [...prev.log, '--- æˆ˜æ–—é˜¶æ®µ ---']
                }));
                setTimeout(resolveBattle, 500);
            } else {
                const names = {
                    blueDeploy: 'è“æ–¹éƒ¨ç½²é˜¶æ®µ',
                    redSupport: 'çº¢æ–¹æ”¯æ´é˜¶æ®µ'
                };
                setGameState(prev => ({
                    ...prev,
                    phase: target,
                    selectedCard: null,
                    log: [...prev.log, `--- ${names[target]} ---`]
                }));
            }
        };

        const resolveBattle = async () => {
            let redBF = gameState.red.battlefield.map(c => c ? {...c} : null);
            let blueBF = gameState.blue.battlefield.map(c => c ? {...c} : null);
            let redHP = gameState.red.health;
            let blueHP = gameState.blue.health;
            let discard = [...gameState.discardPile];
            let logs = [];

            for (let i = 0; i < 4; i++) {
                setBattleAnimation({ active: true, lane: i });
                window.SoundManager.playSound('attack');
                await new Promise(r => setTimeout(r, 1000));

                const rc = redBF[i];
                const bc = blueBF[i];

                if (rc && bc) {
                    rc.hp -= bc.atk;
                    bc.hp -= rc.atk;
                    logs.push(`è·¯çº¿${i+1}: ${rc.name}(${rc.hp}HP) VS ${bc.name}(${bc.hp}HP)`);
                    
                    if (rc.hp <= 0) {
                        discard.push(rc);
                        redBF[i] = null;
                        logs.push(`  çº¢æ–¹ ${rc.name} è¢«å‡»è´¥`);
                    }
                    if (bc.hp <= 0) {
                        discard.push(bc);
                        blueBF[i] = null;
                        logs.push(`  è“æ–¹ ${bc.name} è¢«å‡»è´¥`);
                    }
                } else if (rc) {
                    blueHP -= rc.atk;
                    logs.push(`è·¯çº¿${i+1}: ${rc.name} æ”»å‡»è“æ–¹ï¼Œé€ æˆ ${rc.atk} ä¼¤å®³`);
                } else if (bc) {
                    redHP -= bc.atk;
                    logs.push(`è·¯çº¿${i+1}: ${bc.name} æ”»å‡»çº¢æ–¹ï¼Œé€ æˆ ${bc.atk} ä¼¤å®³`);
                }
            }

            setBattleAnimation({ active: false, lane: -1 });

            let newMDeck = [...gameState.miracleDeck];
            let redHand = [...gameState.red.hand];
            let blueHand = [...gameState.blue.hand];
            let redDrawn = [...gameState.red.miracleDrawn];
            let blueDrawn = [...gameState.blue.miracleDrawn];

            const milestones = [25, 20, 15, 10, 5];
            const drawMiracle = (hp, drawn, hand) => {
                const hit = milestones.some(m => hp <= m && !drawn.includes(m));
                if (hit) {
                    const newDrawn = [...drawn, ...milestones.filter(m => hp <= m && !drawn.includes(m))];
                    const card = newMDeck.pop();
                    if (card) {
                        hand.push(card);
                        return { drawn: newDrawn, drewName: card.name };
                    }
                    return { drawn: newDrawn, drewName: null };
                }
                return { drawn, drewName: null };
            };

            if (redHP < gameState.red.health) {
                const res = drawMiracle(redHP, redDrawn, redHand);
                redDrawn = res.drawn;
                if (res.drewName) logs.push(`çº¢æ–¹è¡€é‡é™è‡³ ${redHP}ï¼ŒæŠ½å–å¥‡è¿¹ç‰Œï¼š${res.drewName}`);
            }
            if (blueHP < gameState.blue.health) {
                const res = drawMiracle(blueHP, blueDrawn, blueHand);
                blueDrawn = res.drawn;
                if (res.drewName) logs.push(`è“æ–¹è¡€é‡é™è‡³ ${blueHP}ï¼ŒæŠ½å–å¥‡è¿¹ç‰Œï¼š${res.drewName}`);
            }

            if (redHP <= 0 || blueHP <= 0) {
                const w = redHP > blueHP ? 'çº¢æ–¹' : (blueHP > redHP ? 'è“æ–¹' : 'å¹³å±€');
                logs.push(`ğŸ‰ ${w === 'å¹³å±€' ? 'å¹³å±€' : w + 'è·èƒœï¼'}`);
                window.SoundManager.playSound('victory');
                setWinner(w);
            } else {
                logs.push('æˆ˜æ–—ç»“ç®—å®Œæˆ');
            }

            setGameState(prev => ({
                ...prev,
                phase: 'idle',
                red: {
                    ...prev.red,
                    battlefield: redBF,
                    health: redHP,
                    hand: redHand,
                    miracleDrawn: redDrawn
                },
                blue: {
                    ...prev.blue,
                    battlefield: blueBF,
                    health: blueHP,
                    hand: blueHand,
                    miracleDrawn: blueDrawn
                },
                miracleDeck: newMDeck,
                discardPile: discard,
                log: [...prev.log, ...logs]
            }));

            setTimeout(() => {
                setGameState(prev => {
                    if (prev.deck.length === 0 && prev.red.hand.length === 0 && prev.blue.hand.length === 0 && !winner) {
                        const w = prev.red.health > prev.blue.health ? 'çº¢æ–¹' : (prev.blue.health > prev.red.health ? 'è“æ–¹' : 'å¹³å±€');
                        setWinner(w);
                        window.SoundManager.playSound('victory');
                        return {
                            ...prev,
                            log: [...prev.log, 'ç‰Œåº“è€—å°½', `${w === 'å¹³å±€' ? 'å¹³å±€' : w + 'è·èƒœ'}`]
                        };
                    }
                    return prev;
                });
            }, 100);
        };

        const reset = () => {
            setWinner(null);
            setGamePhase('notStarted');
            setBattleAnimation({ active: false, lane: -1 });
            setGameState(INIT_STATE);
            setScreen('lobby');
        };

        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        // æ¸²æŸ“é€»è¾‘
        // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
        if (!uiReady) {
            return <div className="text-white text-center mt-40 text-xl">åŠ è½½ä¸­â€¦</div>;
        }

        // ä¸»èœå•
        if (screen === 'menu') {
            return (
                <div className="min-h-screen bg-gradient-to-br from-slate-900 via-blue-900 to-purple-900 flex items-center justify-center p-4">
                    <div className="max-w-2xl w-full">
                        <div className="text-center mb-12">
                            <h1 className="text-6xl font-bold text-white mb-4 drop-shadow-lg">
                                ğŸŒ åœ¨çº¿å¯¹æˆ˜
                            </h1>
                            <p className="text-xl text-gray-300">é€šè¿‡æˆ¿é—´å·ä¸å¥½å‹å¯¹æˆ˜</p>
                        </div>

                        <div className="grid gap-6 mb-8">
                            <button
                                onClick={handleCreateRoom}
                                onMouseEnter={() => window.SoundManager.playSound('hover')}
                                className="group relative overflow-hidden rounded-2xl bg-gradient-to-br from-green-600 to-teal-600 p-8 text-left transform transition-all duration-300 hover:scale-105 hover:shadow-2xl"
                            >
                                <div className="relative z-10">
                                    <div className="text-6xl mb-4">ğŸ </div>
                                    <h2 className="text-3xl font-bold text-white mb-2">åˆ›å»ºæˆ¿é—´</h2>
                                    <p className="text-gray-200">åˆ›å»ºæ–°æˆ¿é—´ï¼Œé‚€è¯·å¥½å‹åŠ å…¥</p>
                                </div>
                            </button>

                            <div className="bg-gradient-to-br from-blue-600 to-purple-600 rounded-2xl p-8">
                                <div className="text-6xl mb-4">ğŸšª</div>
                                <h2 className="text-3xl font-bold text-white mb-4">åŠ å…¥æˆ¿é—´</h2>
                                <div className="flex gap-3">
                                    <input
                                        type="text"
                                        value={roomInput}
                                        onChange={(e) => setRoomInput(e.target.value.toUpperCase())}
                                        placeholder="è¾“å…¥6ä½æˆ¿é—´å·"
                                        maxLength={6}
                                        className="flex-1 px-4 py-3 rounded-lg text-xl font-bold text-center uppercase tracking-wider"
                                        onKeyPress={(e) => e.key === 'Enter' && handleJoinRoom()}
                                    />
                                    <button
                                        onClick={handleJoinRoom}
                                        className="px-6 py-3 bg-white hover:bg-gray-100 text-blue-600 rounded-lg font-bold text-xl transition-all duration-200"
                                    >
                                        åŠ å…¥
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div className="text-center">
                            <button
                                onClick={() => { window.SoundManager.playSound('click'); window.location.href = 'index.html'; }}
                                className="px-8 py-4 bg-gray-700 hover:bg-gray-600 text-white rounded-xl font-bold text-xl transition-all duration-200"
                            >
                                è¿”å›ä¸»ç•Œé¢
                            </button>
                        </div>

                        <div className="mt-8 text-center text-gray-400 text-sm">
                            <p>ğŸ’¡ åˆ›å»ºæˆ¿é—´åï¼Œå°†æˆ¿é—´å·åˆ†äº«ç»™å¥½å‹å³å¯å¼€å§‹å¯¹æˆ˜</p>
                        </div>
                    </div>
                </div>
            );
        }

        // æˆ¿é—´å¤§å…
        if (screen === 'lobby') {
            return (
                <div className="min-h-screen bg-gradient-to-br from-slate-900 via-blue-900 to-purple-900 flex items-center justify-center p-4">
                    <div className="max-w-2xl w-full">
                        <div className="bg-gray-800 rounded-2xl p-8 shadow-2xl">
                            <div className="text-center mb-8">
                                <h2 className="text-4xl font-bold text-white mb-2">
                                    {gameManager.isHost ? 'ğŸ  æˆ¿é—´å·²åˆ›å»º' : 'ğŸšª å·²åŠ å…¥æˆ¿é—´'}
                                </h2>
                                <div className="text-6xl font-bold text-yellow-400 my-6 tracking-widest">
                                    {roomId}
                                </div>
                                <p className="text-gray-300 text-lg">
                                    {gameManager.isHost ? 'å°†æˆ¿é—´å·åˆ†äº«ç»™å¥½å‹' : 'ç­‰å¾…æˆ¿ä¸»å¼€å§‹æ¸¸æˆ'}
                                </p>
                            </div>

                            <div className="grid grid-cols-2 gap-4 mb-8">
                                <div className="bg-red-900/30 border-2 border-red-500 rounded-xl p-6 text-center">
                                    <div className="text-2xl mb-2">ğŸ”´</div>
                                    <div className="text-white font-bold mb-1">çº¢æ–¹ (æˆ¿ä¸»)</div>
                                    <div className={`text-sm ${gameManager.isHost ? 'text-green-400' : 'text-yellow-400'}`}>
                                        {gameManager.isHost ? 'ä½ ' : (opponentConnected ? 'å¯¹æ‰‹å·²è¿æ¥' : 'ç­‰å¾…ä¸­...')}
                                    </div>
                                </div>
                                <div className="bg-blue-900/30 border-2 border-blue-500 rounded-xl p-6 text-center">
                                    <div className="text-2xl mb-2">ğŸ”µ</div>
                                    <div className="text-white font-bold mb-1">è“æ–¹ (åŠ å…¥è€…)</div>
                                    <div className={`text-sm ${!gameManager.isHost ? 'text-green-400' : 'text-yellow-400'}`}>
                                        {!gameManager.isHost ? 'ä½ ' : (opponentConnected ? 'å¯¹æ‰‹å·²è¿æ¥' : 'ç­‰å¾…ä¸­...')}
                                    </div>
                                </div>
                            </div>

                            <div className="flex gap-4">
                                {gameManager.isHost && (
                                    <button
                                        onClick={handleStartGame}
                                        disabled={!opponentConnected}
                                        className={`flex-1 py-4 rounded-xl font-bold text-xl transition-all duration-200 ${
                                            opponentConnected
                                                ? 'bg-green-600 hover:bg-green-700 text-white'
                                                : 'bg-gray-600 text-gray-400 cursor-not-allowed'
                                        }`}
                                    >
                                        {opponentConnected ? 'å¼€å§‹æ¸¸æˆ' : 'ç­‰å¾…å¯¹æ‰‹...'}
                                    </button>
                                )}
                                {!gameManager.isHost && (
                                    <div className="flex-1 py-4 rounded-xl font-bold text-xl text-center bg-gray-700 text-gray-300">
                                        ç­‰å¾…æˆ¿ä¸»å¼€å§‹æ¸¸æˆ...
                                    </div>
                                )}
                                <button
                                    onClick={handleBackToLobby}
                                    className="px-8 py-4 bg-red-600 hover:bg-red-700 text-white rounded-xl font-bold text-xl transition-all duration-200"
                                >
                                    é€€å‡º
                                </button>
                            </div>

                            <div className="mt-6 text-center">
                                <div className="inline-flex items-center gap-2 px-4 py-2 bg-gray-700 rounded-lg">
                                    <div className={`w-3 h-3 rounded-full ${opponentConnected ? 'bg-green-500 animate-pulse' : 'bg-gray-500'}`}></div>
                                    <span className="text-gray-300 text-sm">
                                        {opponentConnected ? 'å¯¹æ‰‹åœ¨çº¿' : 'ç­‰å¾…å¯¹æ‰‹è¿æ¥...'}
                                    </span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        // æ¸¸æˆç•Œé¢ - ä½¿ç”¨ GameUI ç»„ä»¶
        if (screen === 'game') {
            return (
                <GameUI
                    gameState={gameState}
                    gamePhase={gamePhase}
                    allCards={allCards}
                    winner={winner}
                    battleAnimation={battleAnimation}
                    cardShowOverlay={cardShowOverlay}
                    onStartPicking={() => {}}
                    onPickCard={pickCard}
                    onStartTurn={startTurn}
                    onSelectCard={selectCard}
                    onPlayCard={playCard}
                    onUseCardOnTarget={useCardOnTarget}
                    onConfirmUse={confirmUse}
                    onEndPhase={endPhase}
                    onReset={reset}
                    hideOpponentHand={true}
                    myRole={gameManager.playerSide}
                    extraUI={
                        <div className="fixed top-4 right-4 z-50 bg-gray-800 rounded-lg p-3 shadow-lg border-2 border-purple-500">
                            <div className="text-white text-sm">
                                <div className="font-bold mb-1">ğŸŒ åœ¨çº¿å¯¹æˆ˜</div>
                                <div className="text-yellow-400 font-mono">æˆ¿é—´: {roomId}</div>
                                <div className={`text-xs mt-1 ${opponentConnected ? 'text-green-400' : 'text-red-400'}`}>
                                    {opponentConnected ? 'â— å¯¹æ‰‹åœ¨çº¿' : 'â—‹ å¯¹æ‰‹ç¦»çº¿'}
                                </div>
                            </div>
                        </div>
                    }
                />
            );
        }

        return null;
    };

    ReactDOM.render(<OnlineGame />, document.getElementById('root'));
    </script>
</body>
</html>
