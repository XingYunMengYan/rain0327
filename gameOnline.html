<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å››è·¯çº¿å¡ç‰Œå¯¹æˆ˜ â€” åœ¨çº¿å¯¹æˆ˜</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.pubnub.com/sdk/javascript/pubnub.7.4.0.js"></script>
    <script src="shared.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
    const { useState, useEffect, useCallback, useRef } = React;

    // PubNubé…ç½®
    const PUBNUB_CONFIG = {
        publishKey: 'demo',
        subscribeKey: 'demo',
    };

    const ROOMS = ['room1', 'room2', 'room3', 'room4', 'room5', 'room6'];

    // æ–­çº¿é‡è¿ç®¡ç†
    const ReconnectManager = {
        STORAGE_KEY: 'cardgame_online_session',
        saveSession(data) {
            try {
                localStorage.setItem(this.STORAGE_KEY, JSON.stringify({
                    ...data,
                    timestamp: Date.now()
                }));
            } catch (e) {}
        },
        loadSession() {
            try {
                const data = localStorage.getItem(this.STORAGE_KEY);
                if (!data) return null;
                const session = JSON.parse(data);
                const age = Date.now() - session.timestamp;
                if (age > 30 * 60 * 1000) {
                    this.clearSession();
                    return null;
                }
                return session;
            } catch (e) {
                return null;
            }
        },
        clearSession() {
            localStorage.removeItem(this.STORAGE_KEY);
        }
    };

    // åœ¨çº¿æ¸¸æˆç®¡ç†ç±»
    class OnlineGameManager {
        constructor() {
            this.pubnub = null;
            this.roomId = null;
            this.playerId = null;
            this.playerSide = null;
            this.isReady = false;
            this.onMessageCallback = null;
            this.onPresenceCallback = null;
        }

        init(existingPlayerId = null) {
            this.playerId = existingPlayerId || 'p_' + Math.random().toString(36).substr(2, 9);
            this.pubnub = new PubNub({
                ...PUBNUB_CONFIG,
                uuid: this.playerId,
                heartbeatInterval: 10
            });
        }

        joinRoom(roomId) {
            this.roomId = roomId;
            this.subscribeToRoom();
            this.sendMessage({ type: 'player-join', playerId: this.playerId });
        }

        subscribeToRoom() {
            if (!this.pubnub || !this.roomId) return;
            this.pubnub.addListener({
                message: (event) => {
                    if (this.onMessageCallback) {
                        this.onMessageCallback(event.message);
                    }
                },
                presence: (event) => {
                    if (this.onPresenceCallback) {
                        this.onPresenceCallback(event);
                    }
                }
            });
            this.pubnub.subscribe({
                channels: [this.roomId],
                withPresence: true
            });
        }

        sendMessage(message) {
            if (!this.pubnub || !this.roomId) return;
            this.pubnub.publish({
                channel: this.roomId,
                message: {
                    ...message,
                    senderId: this.playerId,
                    timestamp: Date.now()
                }
            });
        }

        setReady(ready) {
            this.isReady = ready;
            this.sendMessage({ 
                type: 'player-ready', 
                playerId: this.playerId,
                ready: ready
            });
        }

        leaveRoom() {
            if (this.pubnub && this.roomId) {
                this.sendMessage({ type: 'player-leave', playerId: this.playerId });
                this.pubnub.unsubscribe({ channels: [this.roomId] });
            }
            this.roomId = null;
            this.playerSide = null;
            this.isReady = false;
        }

        setMessageCallback(callback) {
            this.onMessageCallback = callback;
        }

        setPresenceCallback(callback) {
            this.onPresenceCallback = callback;
        }
    }

    const OnlineGame = () => {
        const [uiReady, setUiReady] = useState(false);
        const [allCards, setAllCards] = useState([]);
        
        useEffect(() => { 
            window.GameUILoader.load().then(() => setUiReady(true)); 
            window.SoundManager.restoreFromStorage(); 
        }, []);

        useEffect(() => { 
            window.loadCards().then(cards => setAllCards(cards)).catch(err => { 
                console.error('åŠ è½½å¡ç‰Œå¤±è´¥', err); 
                alert('æ— æ³•åŠ è½½ card_data.csv'); 
            }); 
        }, []);

        // åˆå§‹æ¸¸æˆçŠ¶æ€
        const INIT_STATE = {
            turn: 0, 
            phase: 'idle',
            red: { 
                health: 30, 
                coins: 0, 
                hand: [], 
                battlefield: [null, null, null, null], 
                miracleDrawn: [30],
                pickPool: []
            },
            blue: { 
                health: 30, 
                coins: 0, 
                hand: [], 
                battlefield: [null, null, null, null], 
                miracleDrawn: [30],
                pickPool: []
            },
            deck: [], 
            miracleDeck: [], 
            discardPile: [], 
            initialCards: [],
            selectedCard: null, 
            log: []
        };

        const [screen, setScreen] = useState('lobby');
        const [currentRoomId, setCurrentRoomId] = useState(null);
        const gameManagerRef = useRef(null);
        const [roomPlayers, setRoomPlayers] = useState([]);
        const [showReconnectPrompt, setShowReconnectPrompt] = useState(false);
        const [reconnectData, setReconnectData] = useState(null);
        const [showRoulette, setShowRoulette] = useState(false);
        const [rouletteResult, setRouletteResult] = useState(null);
        const [gameState, setGameState] = useState(INIT_STATE);
        const gameStateRef = useRef(gameState);
        const [gamePhase, setGamePhase] = useState('notStarted');
        const [winner, setWinner] = useState(null);
        const [battleAnimation, setBattleAnimation] = useState({ active: false, lane: -1 });
        const [cardShowOverlay, setCardShowOverlay] = useState(null);

        // ğŸ”‘ å…³é”®ä¿®å¤ï¼šç”¨ ref è®°å½•é€‰ç‰Œå®Œæˆè®¡æ•°ï¼ˆè€Œéä¾èµ–å¼‚æ­¥stateï¼‰
        const myPickCountRef = useRef(0); // æˆ‘é€‰äº†å‡ å¼ ç‰Œï¼ˆä¸åŒ…æ‹¬åˆå§‹å¥‡è¿¹ç‰Œï¼‰
        const opponentPickedRef = useRef(false); // å¯¹æ‰‹æ˜¯å¦å®Œæˆé€‰ç‰Œ

        useEffect(() => {
            gameStateRef.current = gameState;
        }, [gameState]);

        useEffect(() => {
            gameManagerRef.current = new OnlineGameManager();
            const session = ReconnectManager.loadSession();
            if (session && session.roomId) {
                setReconnectData(session);
                setShowReconnectPrompt(true);
            }
            return () => {
                if (gameManagerRef.current) {
                    gameManagerRef.current.leaveRoom();
                }
            };
        }, []);

        useEffect(() => {
            if (screen === 'game' && gameManagerRef.current) {
                ReconnectManager.saveSession({
                    roomId: currentRoomId,
                    playerId: gameManagerRef.current.playerId,
                    playerSide: gameManagerRef.current.playerSide,
                    gameState,
                    gamePhase,
                    screen
                });
            }
        }, [gameState, gamePhase, screen, currentRoomId]);

        const addLog = useCallback((msg) => { 
            setGameState(prev => ({ ...prev, log: [...prev.log, msg] })); 
        }, []);

        const showCardOverlay = useCallback((card) => {
            setCardShowOverlay(card);
            const dur = card.type === 'miracle' ? 2000 : 1000;
            window.SoundManager.playSound(card.type === 'miracle' ? 'miracle' : 'place');
            setTimeout(() => setCardShowOverlay(null), dur);
        }, []);

        const handleReconnect = () => {
            if (!reconnectData) return;
            gameManagerRef.current.init(reconnectData.playerId);
            gameManagerRef.current.playerSide = reconnectData.playerSide;
            gameManagerRef.current.joinRoom(reconnectData.roomId);
            setCurrentRoomId(reconnectData.roomId);
            setGameState(reconnectData.gameState || INIT_STATE);
            setGamePhase(reconnectData.gamePhase || 'notStarted');
            setScreen('game');
            setShowReconnectPrompt(false);
            gameManagerRef.current.sendMessage({ 
                type: 'player-reconnect',
                playerSide: reconnectData.playerSide
            });
            window.SoundManager.playSound('click');
        };

        const handleNewGame = () => {
            ReconnectManager.clearSession();
            setShowReconnectPrompt(false);
            window.SoundManager.playSound('click');
        };

        const handleNetworkMessage = useCallback((message) => {
            if (message.senderId === gameManagerRef.current.playerId) return;

            switch (message.type) {
                case 'player-join':
                    setRoomPlayers(prev => {
                        if (prev.find(p => p.playerId === message.playerId)) return prev;
                        return [...prev, { playerId: message.playerId, ready: false }];
                    });
                    window.SoundManager.playSound('click');
                    gameManagerRef.current.sendMessage({ 
                        type: 'player-exist', 
                        playerId: gameManagerRef.current.playerId,
                        ready: gameManagerRef.current.isReady
                    });
                    break;

                case 'player-exist':
                    setRoomPlayers(prev => {
                        if (prev.find(p => p.playerId === message.playerId)) {
                            return prev.map(p => 
                                p.playerId === message.playerId 
                                    ? { ...p, ready: message.ready } 
                                    : p
                            );
                        }
                        return [...prev, { playerId: message.playerId, ready: message.ready }];
                    });
                    break;

                case 'player-ready':
                    setRoomPlayers(prev => 
                        prev.map(p => 
                            p.playerId === message.playerId 
                                ? { ...p, ready: message.ready } 
                                : p
                        )
                    );
                    break;

                case 'player-leave':
                    setRoomPlayers(prev => prev.filter(p => p.playerId !== message.playerId));
                    if (screen === 'game') addLog('âš ï¸ å¯¹æ‰‹å·²ç¦»å¼€æˆ¿é—´');
                    break;

                case 'start-roulette':
                    startRouletteAnimation(message.seed);
                    break;

                case 'roulette-result':
                    applyRouletteResult(message.result);
                    break;

                case 'start-game':
                    initializeGameWithSeed(message.seed);
                    break;

                case 'player-reconnect':
                    addLog(`${message.playerSide === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}å·²é‡æ–°è¿æ¥`);
                    break;

                case 'pick-card':
                    handleRemotePickCard(message);
                    break;

                case 'pick-complete':
                    handleRemotePickComplete(message);
                    break;

                case 'play-card':
                    handleRemotePlayCard(message);
                    break;

                case 'use-support':
                    handleRemoteUseSupport(message);
                    break;

                case 'confirm-use':
                    handleRemoteConfirmUse(message);
                    break;

                case 'end-phase':
                    handleRemoteEndPhase();
                    break;

                case 'start-turn':
                    handleRemoteStartTurn();
                    break;
            }
        }, [screen, addLog]);

        useEffect(() => {
            if (!gameManagerRef.current) return;
            gameManagerRef.current.setMessageCallback(handleNetworkMessage);
            gameManagerRef.current.setPresenceCallback((event) => {
                if (event.action === 'timeout' || event.action === 'leave') {
                    if (event.uuid !== gameManagerRef.current.playerId) {
                        setRoomPlayers(prev => prev.filter(p => p.playerId !== event.uuid));
                        if (screen === 'game') addLog('âš ï¸ å¯¹æ‰‹æ–­çº¿');
                    }
                }
            });
        }, [handleNetworkMessage, screen, addLog]);

        const handleJoinRoom = (roomId) => {
            if (!gameManagerRef.current.pubnub) {
                gameManagerRef.current.init();
            }
            gameManagerRef.current.joinRoom(roomId);
            setCurrentRoomId(roomId);
            setScreen('room');
            setRoomPlayers([{ playerId: gameManagerRef.current.playerId, ready: false }]);
            window.SoundManager.playSound('click');
        };

        const handleToggleReady = () => {
            const newReady = !gameManagerRef.current.isReady;
            gameManagerRef.current.setReady(newReady);
            setRoomPlayers(prev => 
                prev.map(p => 
                    p.playerId === gameManagerRef.current.playerId 
                        ? { ...p, ready: newReady } 
                        : p
                )
            );
            window.SoundManager.playSound('click');
        };

        const handleLeaveRoom = () => {
            gameManagerRef.current.leaveRoom();
            setCurrentRoomId(null);
            setRoomPlayers([]);
            setScreen('lobby');
            window.SoundManager.playSound('click');
        };

        const handleBackToLobby = () => {
            if (confirm('ç¡®å®šè¦ç¦»å¼€æ¸¸æˆå—ï¼Ÿè¿›åº¦å°†ä¼šä¸¢å¤±ã€‚')) {
                gameManagerRef.current.leaveRoom();
                ReconnectManager.clearSession();
                setCurrentRoomId(null);
                setRoomPlayers([]);
                setGameState(INIT_STATE);
                setGamePhase('notStarted');
                setWinner(null);
                setScreen('lobby');
                window.SoundManager.playSound('click');
            }
        };

        const canStartGame = roomPlayers.length === 2 && roomPlayers.every(p => p.ready);

        useEffect(() => {
            if (screen === 'room' && canStartGame) {
                const sortedPlayers = [...roomPlayers].sort((a, b) => a.playerId.localeCompare(b.playerId));
                const isHost = sortedPlayers[0].playerId === gameManagerRef.current.playerId;

                if (isHost) {
                    const seed = Date.now();
                    gameManagerRef.current.sendMessage({ type: 'start-roulette', seed });
                    startRouletteAnimation(seed);
                }
            }
        }, [canStartGame, screen, roomPlayers]);

        const startRouletteAnimation = (seed) => {
            setShowRoulette(true);
            setScreen('roulette');
            window.SoundManager.playSound('spin');
            setTimeout(() => {
                const seededRandom = Math.sin(seed) * 10000;
                const randomValue = seededRandom - Math.floor(seededRandom);
                const players = [...roomPlayers].sort((a, b) => a.playerId.localeCompare(b.playerId));
                const result = randomValue > 0.5 ? 
                    { [players[0].playerId]: 'red', [players[1].playerId]: 'blue' } :
                    { [players[0].playerId]: 'blue', [players[1].playerId]: 'red' };
                gameManagerRef.current.sendMessage({ type: 'roulette-result', result });
                applyRouletteResult(result);
            }, 2000);
        };

        const applyRouletteResult = (result) => {
            const mySide = result[gameManagerRef.current.playerId];
            gameManagerRef.current.playerSide = mySide;
            setRouletteResult(mySide);
            addLog(`æŠ½ç­¾ç»“æœï¼šä½ æ˜¯${mySide === 'red' ? 'çº¢æ–¹ğŸ”´' : 'è“æ–¹ğŸ”µ'}`);
            setTimeout(() => {
                setShowRoulette(false);
                if (mySide === 'red') {
                    const gameSeed = Date.now();
                    gameManagerRef.current.sendMessage({ type: 'start-game', seed: gameSeed });
                    initializeGameWithSeed(gameSeed);
                }
            }, 1500);
        };

        const initializeGameWithSeed = (seed) => {
            if (!allCards || allCards.length === 0) return;
            
            const seededRandom = (s) => {
                const x = Math.sin(s++) * 10000;
                return x - Math.floor(x);
            };
            
            let currentSeed = seed;
            const seededShuffle = (arr) => {
                const a = [...arr];
                for (let i = a.length - 1; i > 0; i--) {
                    const j = Math.floor(seededRandom(currentSeed++) * (i + 1));
                    [a[i], a[j]] = [a[j], a[i]];
                }
                return a;
            };
            
            const regular = allCards.filter(c => c.type !== 'miracle');
            const miracles = allCards.filter(c => c.type === 'miracle');
            const deck = seededShuffle(regular.map(window.createCard));
            const miracleDeck = seededShuffle(miracles.map(window.createCard));
            
            const redSix = deck.slice(0, 6);
            const blueSix = deck.slice(6, 12);
            const rest = deck.slice(12);
            const mDeck = [...miracleDeck];
            const redM = mDeck.pop();
            const blueM = mDeck.pop();

            const mySide = gameManagerRef.current.playerSide;

            // ğŸ”‘ é‡ç½®é€‰ç‰Œè®¡æ•°å™¨
            myPickCountRef.current = 0;
            opponentPickedRef.current = false;

            setGameState({
                ...INIT_STATE,
                red: { 
                    ...INIT_STATE.red, 
                    hand: redM ? [redM] : [],
                    pickPool: redSix
                },
                blue: { 
                    ...INIT_STATE.blue, 
                    hand: blueM ? [blueM] : [],
                    pickPool: blueSix
                },
                deck: rest,
                miracleDeck: mDeck,
                initialCards: mySide === 'red' ? redSix : blueSix,
                log: [
                    'ğŸŒ åœ¨çº¿æ¸¸æˆå¼€å§‹ï¼',
                    `ä½ æ˜¯${mySide === 'red' ? 'çº¢æ–¹ğŸ”´' : 'è“æ–¹ğŸ”µ'}`,
                    'åŒæ–¹å„æŠ½å–1å¼ å¥‡è¿¹ç‰Œ',
                    '--- é€‰ç‰Œé˜¶æ®µå¼€å§‹ ---'
                ]
            });
            
            setGamePhase(mySide === 'red' ? 'redPicking' : 'bluePicking');
            setScreen('game');
        };

        // ğŸ”‘ æ£€æŸ¥åŒæ–¹æ˜¯å¦éƒ½å®Œæˆï¼ˆåœ¨ä»»ä½•æ—¶å€™éƒ½å¯ä»¥è°ƒç”¨ï¼‰
        const tryStartGame = useCallback(() => {
            console.log('æ£€æŸ¥æ˜¯å¦å¯ä»¥å¼€å§‹æ¸¸æˆ:', {
                myPickCount: myPickCountRef.current,
                opponentPicked: opponentPickedRef.current
            });

            // ğŸ¯ æ ¸å¿ƒåˆ¤æ–­ï¼šæˆ‘é€‰äº†2å¼  && å¯¹æ‰‹å‘äº†å®Œæˆæ¶ˆæ¯
            if (myPickCountRef.current >= 2 && opponentPickedRef.current) {
                console.log('âœ… åŒæ–¹éƒ½å®Œæˆï¼Œå¼€å§‹æ¸¸æˆï¼');
                
                setGamePhase('playing');
                setGameState(prev => ({
                    ...prev,
                    initialCards: [],
                    log: [...prev.log, '--- åŒæ–¹é€‰ç‰Œå®Œæˆï¼Œæ¸¸æˆæ­£å¼å¼€å§‹ï¼---']
                }));
                
                // é‡ç½®æ ‡è®°ï¼Œé˜²æ­¢é‡å¤è§¦å‘
                myPickCountRef.current = -999;
                opponentPickedRef.current = false;
            }
        }, []);

        const pickCard = (card) => {
            const currentPhase = gamePhase;
            if (currentPhase !== 'redPicking' && currentPhase !== 'bluePicking') return;
            
            const mySide = gameManagerRef.current.playerSide;
            const correctPhase = (mySide === 'red' && currentPhase === 'redPicking') ||
                                (mySide === 'blue' && currentPhase === 'bluePicking');
            
            if (!correctPhase) return;

            window.SoundManager.playSound('click');

            // ğŸ”‘ ç«‹å³æ›´æ–°è®¡æ•°å™¨ï¼ˆåŒæ­¥çš„ï¼ï¼‰
            myPickCountRef.current += 1;
            const newCount = myPickCountRef.current;

            console.log(`é€‰äº†ç¬¬ ${newCount} å¼ ç‰Œ:`, card.name);
            
            // å‘é€é€‰ç‰Œæ¶ˆæ¯
            gameManagerRef.current.sendMessage({ 
                type: 'pick-card', 
                cardId: card.instanceId,
                side: mySide
            });

            // å¦‚æœé€‰æ»¡2å¼ ï¼Œç«‹å³å‘é€å®Œæˆæ¶ˆæ¯
            if (newCount >= 2) {
                console.log('æˆ‘çš„é€‰ç‰Œå·²å®Œæˆï¼Œå‘é€å®Œæˆæ¶ˆæ¯');
                gameManagerRef.current.sendMessage({ 
                    type: 'pick-complete',
                    side: mySide
                });
                // ç«‹å³æ£€æŸ¥å¯¹æ‰‹æ˜¯å¦ä¹Ÿå®Œæˆäº†
                tryStartGame();
            }

            // æ›´æ–°UIçŠ¶æ€ï¼ˆå¼‚æ­¥çš„ï¼Œä½†ä¸å½±å“åˆ¤æ–­é€»è¾‘ï¼‰
            setGameState(prev => {
                const newHand = [...prev[mySide].hand, card];
                const newPool = prev[mySide].pickPool.filter(c => c.instanceId !== card.instanceId);
                const newInitialCards = prev.initialCards.filter(c => c.instanceId !== card.instanceId);
                const isDone = newCount >= 2;

                const newLog = [...prev.log, `ä½ é€‰æ‹©äº† ${card.name}`];
                if (isDone) {
                    newLog.push('--- ä½ çš„é€‰ç‰Œå·²å®Œæˆï¼Œç­‰å¾…å¯¹æ‰‹... ---');
                }

                return {
                    ...prev,
                    [mySide]: { 
                        ...prev[mySide], 
                        hand: newHand,
                        pickPool: isDone ? [] : newPool
                    },
                    initialCards: isDone ? [] : newInitialCards,
                    log: newLog
                };
            });
        };

        const handleRemotePickCard = (message) => {
            const opponentSide = message.side;
            const cardId = message.cardId;

            setGameState(prev => {
                const card = prev[opponentSide].pickPool.find(c => c.instanceId === cardId);
                if (!card) return prev;

                const newHand = [...prev[opponentSide].hand, card];
                const newPool = prev[opponentSide].pickPool.filter(c => c.instanceId !== cardId);
                const isOpponentDone = newHand.length >= 3;

                return {
                    ...prev,
                    [opponentSide]: { 
                        ...prev[opponentSide], 
                        hand: newHand,
                        pickPool: isOpponentDone ? [] : newPool
                    },
                    log: [...prev.log, `${opponentSide === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}é€‰äº†ä¸€å¼ ç‰Œ`]
                };
            });
        };

        const handleRemotePickComplete = useCallback((message) => {
            console.log('æ”¶åˆ°å¯¹æ‰‹é€‰ç‰Œå®Œæˆæ¶ˆæ¯:', message.side);
            
            // ğŸ”‘ æ ‡è®°å¯¹æ‰‹å·²å®Œæˆï¼ˆåŒæ­¥çš„ï¼ï¼‰
            opponentPickedRef.current = true;
            
            // ç«‹å³æ£€æŸ¥æ˜¯å¦å¯ä»¥å¼€å§‹æ¸¸æˆ
            tryStartGame();
        }, [tryStartGame]);

        const startTurn = () => {
            if (gameManagerRef.current.playerSide !== 'red') return;
            gameManagerRef.current.sendMessage({ type: 'start-turn' });
            doStartTurn();
        };

        const handleRemoteStartTurn = () => { 
            doStartTurn(); 
        };

        const doStartTurn = () => {
            setGameState(prev => {
                const newTurn = prev.turn + 1;
                const coins = Math.min(newTurn, 10);
                const logs = [`--- ç¬¬${newTurn}å›åˆå¼€å§‹ ---`, `åŒæ–¹è·å¾— ${coins} é‡‘å¸`];
                let deck = [...prev.deck];
                let redHand = [...prev.red.hand];
                let blueHand = [...prev.blue.hand];
                
                if (newTurn >= 2) {
                    for (let i = 0; i < 2; i++) {
                        const r = deck.pop();
                        if (r) redHand.push(r);
                        const b = deck.pop();
                        if (b) blueHand.push(b);
                    }
                    logs.push('åŒæ–¹å„æŠ½2å¼ ç‰Œ');
                } else {
                    logs.push('ç¬¬ä¸€å›åˆä¸æŠ½ç‰Œ');
                }
                
                return {
                    ...prev,
                    turn: newTurn,
                    phase: 'redDeploy',
                    deck,
                    red: { ...prev.red, coins, hand: redHand },
                    blue: { ...prev.blue, coins, hand: blueHand },
                    log: [...prev.log, ...logs]
                };
            });
        };

        const selectCard = (card, player) => {
            const phase = gameStateRef.current.phase;
            if (player !== gameManagerRef.current.playerSide || phase === 'idle' || phase === 'battle') return;
            
            const isRedPhase = phase === 'redDeploy' || phase === 'redSupport';
            if ((isRedPhase && player !== 'red') || (!isRedPhase && player !== 'blue')) return;
            
            setGameState(prev => {
                if (prev.selectedCard?.instanceId === card.instanceId) {
                    return { ...prev, selectedCard: null };
                }
                return { ...prev, selectedCard: card };
            });
        };

        const playCard = (laneIndex) => {
            const state = gameStateRef.current;
            const card = state.selectedCard;
            if (!card || card.type !== 'battlefield') return;
            
            const phase = state.phase;
            const player = (phase === 'redDeploy' || phase === 'redSupport') ? 'red' : 'blue';
            if (player !== gameManagerRef.current.playerSide) return;
            
            const playerState = state[player];
            if (playerState.coins < card.cost) {
                addLog('é‡‘å¸ä¸è¶³ï¼');
                return;
            }
            if (playerState.battlefield[laneIndex] !== null) {
                addLog('è¯¥è·¯çº¿å·²æœ‰å¡ç‰Œï¼');
                return;
            }
            
            window.SoundManager.playSound('place');
            gameManagerRef.current.sendMessage({ 
                type: 'play-card', 
                card: card,
                laneIndex: laneIndex
            });
            
            setGameState(prev => {
                const bf = [...prev[player].battlefield];
                bf[laneIndex] = { ...card };
                return {
                    ...prev,
                    [player]: {
                        ...prev[player],
                        battlefield: bf,
                        hand: prev[player].hand.filter(c => c.instanceId !== card.instanceId),
                        coins: prev[player].coins - card.cost
                    },
                    selectedCard: null,
                    log: [...prev.log, `${player === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}åœ¨è·¯çº¿${laneIndex+1}æ”¾ç½®äº† ${card.name}`]
                };
            });
        };

        const handleRemotePlayCard = (message) => {
            const state = gameStateRef.current;
            const phase = state.phase;
            const player = (phase === 'redDeploy' || phase === 'redSupport') ? 'red' : 'blue';
            if (player === gameManagerRef.current.playerSide) return;
            
            const card = message.card;
            const laneIndex = message.laneIndex;
            
            setGameState(prev => {
                const bf = [...prev[player].battlefield];
                bf[laneIndex] = { ...card };
                return {
                    ...prev,
                    [player]: {
                        ...prev[player],
                        battlefield: bf,
                        hand: prev[player].hand.filter(c => c.instanceId !== card.instanceId),
                        coins: prev[player].coins - card.cost
                    },
                    log: [...prev.log, `${player === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}åœ¨è·¯çº¿${laneIndex+1}æ”¾ç½®äº† ${card.name}`]
                };
            });
        };

        const useCardOnTarget = (targetPlayer, laneIndex) => {
            const state = gameStateRef.current;
            const card = state.selectedCard;
            if (!card || (card.type !== 'support' && card.type !== 'miracle')) return;
            
            const phase = state.phase;
            const player = (phase === 'redDeploy' || phase === 'redSupport') ? 'red' : 'blue';
            if (player !== gameManagerRef.current.playerSide) return;
            
            const playerState = state[player];
            const target = state[targetPlayer].battlefield[laneIndex];
            if (!target) {
                addLog('ç›®æ ‡ä½ç½®æ²¡æœ‰å•ä½ï¼');
                return;
            }
            
            const cost = card.type === 'miracle' ? 0 : card.cost;
            if (playerState.coins < cost) {
                addLog('é‡‘å¸ä¸è¶³ï¼');
                return;
            }
            
            addLog(`${player === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}å¯¹ ${target.name} ä½¿ç”¨äº† ${card.name}`);
            showCardOverlay(card);
            
            gameManagerRef.current.sendMessage({ 
                type: 'use-support', 
                card: card,
                targetPlayer: targetPlayer,
                laneIndex: laneIndex
            });
            
            setGameState(prev => ({
                ...prev,
                [player]: {
                    ...playerState,
                    hand: playerState.hand.filter(c => c.instanceId !== card.instanceId),
                    coins: playerState.coins - cost
                },
                discardPile: [...prev.discardPile, card],
                selectedCard: null
            }));
        };

        const handleRemoteUseSupport = (message) => {
            const state = gameStateRef.current;
            const phase = state.phase;
            const player = (phase === 'redDeploy' || phase === 'redSupport') ? 'red' : 'blue';
            if (player === gameManagerRef.current.playerSide) return;
            
            const card = message.card;
            const targetPlayer = message.targetPlayer;
            const laneIndex = message.laneIndex;
            const playerState = state[player];
            const target = state[targetPlayer].battlefield[laneIndex];
            
            addLog(`${player === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}å¯¹ ${target?.name || 'ç›®æ ‡'} ä½¿ç”¨äº† ${card.name}`);
            showCardOverlay(card);
            
            setGameState(prev => ({
                ...prev,
                [player]: {
                    ...playerState,
                    hand: playerState.hand.filter(c => c.instanceId !== card.instanceId),
                    coins: playerState.coins - (card.type === 'miracle' ? 0 : card.cost)
                },
                discardPile: [...prev.discardPile, card]
            }));
        };

        const confirmUse = () => {
            const state = gameStateRef.current;
            const card = state.selectedCard;
            if (!card) return;
            
            const phase = state.phase;
            const player = (phase === 'redDeploy' || phase === 'redSupport') ? 'red' : 'blue';
            if (player !== gameManagerRef.current.playerSide) return;
            
            const playerState = state[player];
            const cost = card.type === 'miracle' ? 0 : card.cost;
            if (playerState.coins < cost) {
                addLog('é‡‘å¸ä¸è¶³ï¼');
                return;
            }
            
            addLog(`${player === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}ä½¿ç”¨äº† ${card.name}`);
            showCardOverlay(card);
            
            gameManagerRef.current.sendMessage({ 
                type: 'confirm-use', 
                card: card
            });
            
            setGameState(prev => ({
                ...prev,
                [player]: {
                    ...playerState,
                    hand: playerState.hand.filter(c => c.instanceId !== card.instanceId),
                    coins: playerState.coins - cost
                },
                discardPile: [...prev.discardPile, card],
                selectedCard: null
            }));
        };

        const handleRemoteConfirmUse = (message) => {
            const state = gameStateRef.current;
            const phase = state.phase;
            const player = (phase === 'redDeploy' || phase === 'redSupport') ? 'red' : 'blue';
            if (player === gameManagerRef.current.playerSide) return;
            
            const card = message.card;
            const playerState = state[player];
            
            addLog(`${player === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}ä½¿ç”¨äº† ${card.name}`);
            showCardOverlay(card);
            
            setGameState(prev => ({
                ...prev,
                [player]: {
                    ...playerState,
                    hand: playerState.hand.filter(c => c.instanceId !== card.instanceId),
                    coins: playerState.coins - (card.type === 'miracle' ? 0 : card.cost)
                },
                discardPile: [...prev.discardPile, card]
            }));
        };

        const endPhase = () => {
            const phase = gameStateRef.current.phase;
            const player = (phase === 'redDeploy' || phase === 'redSupport') ? 'red' : 'blue';
            if (player !== gameManagerRef.current.playerSide) return;
            
            gameManagerRef.current.sendMessage({ type: 'end-phase' });
            doEndPhase();
        };

        const handleRemoteEndPhase = () => { 
            doEndPhase(); 
        };

        const doEndPhase = () => {
            const phase = gameStateRef.current.phase;
            const next = {
                redDeploy: 'blueDeploy',
                blueDeploy: 'redSupport',
                redSupport: 'battle'
            };
            const target = next[phase];
            
            if (target === 'battle') {
                setGameState(prev => ({
                    ...prev,
                    phase: 'battle',
                    selectedCard: null,
                    log: [...prev.log, '--- æˆ˜æ–—é˜¶æ®µ ---']
                }));
                setTimeout(resolveBattle, 500);
            } else {
                const names = {
                    blueDeploy: 'è“æ–¹éƒ¨ç½²é˜¶æ®µ',
                    redSupport: 'çº¢æ–¹æ”¯æ´é˜¶æ®µ'
                };
                setGameState(prev => ({
                    ...prev,
                    phase: target,
                    selectedCard: null,
                    log: [...prev.log, `--- ${names[target]} ---`]
                }));
            }
        };

        const resolveBattle = async () => {
            const state = gameStateRef.current;
            let redBF = state.red.battlefield.map(c => c ? {...c} : null);
            let blueBF = state.blue.battlefield.map(c => c ? {...c} : null);
            let redHP = state.red.health;
            let blueHP = state.blue.health;
            let discard = [...state.discardPile];
            let logs = [];
            
            for (let i = 0; i < 4; i++) {
                setBattleAnimation({ active: true, lane: i });
                window.SoundManager.playSound('attack');
                await new Promise(r => setTimeout(r, 1000));
                
                const rc = redBF[i];
                const bc = blueBF[i];
                
                if (rc && bc) {
                    rc.hp -= bc.atk;
                    bc.hp -= rc.atk;
                    logs.push(`è·¯çº¿${i+1}: ${rc.name}(${rc.hp}HP) VS ${bc.name}(${bc.hp}HP)`);
                    if (rc.hp <= 0) {
                        discard.push(rc);
                        redBF[i] = null;
                        logs.push(`  çº¢æ–¹ ${rc.name} è¢«å‡»è´¥`);
                    }
                    if (bc.hp <= 0) {
                        discard.push(bc);
                        blueBF[i] = null;
                        logs.push(`  è“æ–¹ ${bc.name} è¢«å‡»è´¥`);
                    }
                } else if (rc) {
                    blueHP -= rc.atk;
                    logs.push(`è·¯çº¿${i+1}: ${rc.name} æ”»å‡»è“æ–¹ï¼Œé€ æˆ ${rc.atk} ä¼¤å®³`);
                } else if (bc) {
                    redHP -= bc.atk;
                    logs.push(`è·¯çº¿${i+1}: ${bc.name} æ”»å‡»çº¢æ–¹ï¼Œé€ æˆ ${bc.atk} ä¼¤å®³`);
                }
            }
            
            setBattleAnimation({ active: false, lane: -1 });
            
            let newMDeck = [...state.miracleDeck];
            let redHand = [...state.red.hand];
            let blueHand = [...state.blue.hand];
            let redDrawn = [...state.red.miracleDrawn];
            let blueDrawn = [...state.blue.miracleDrawn];
            
            const milestones = [25, 20, 15, 10, 5];
            const drawMiracle = (hp, drawn, hand) => {
                const hit = milestones.some(m => hp <= m && !drawn.includes(m));
                if (hit) {
                    const newDrawn = [...drawn, ...milestones.filter(m => hp <= m && !drawn.includes(m))];
                    const card = newMDeck.pop();
                    if (card) {
                        hand.push(card);
                        return { drawn: newDrawn, drewName: card.name };
                    }
                    return { drawn: newDrawn, drewName: null };
                }
                return { drawn, drewName: null };
            };
            
            if (redHP < state.red.health) {
                const res = drawMiracle(redHP, redDrawn, redHand);
                redDrawn = res.drawn;
                if (res.drewName) logs.push(`çº¢æ–¹è¡€é‡é™è‡³ ${redHP}ï¼ŒæŠ½å–å¥‡è¿¹ç‰Œï¼š${res.drewName}`);
            }
            if (blueHP < state.blue.health) {
                const res = drawMiracle(blueHP, blueDrawn, blueHand);
                blueDrawn = res.drawn;
                if (res.drewName) logs.push(`è“æ–¹è¡€é‡é™è‡³ ${blueHP}ï¼ŒæŠ½å–å¥‡è¿¹ç‰Œï¼š${res.drewName}`);
            }
            
            if (redHP <= 0 || blueHP <= 0) {
                const w = redHP > blueHP ? 'çº¢æ–¹' : (blueHP > redHP ? 'è“æ–¹' : 'å¹³å±€');
                logs.push(`ğŸ‰ ${w === 'å¹³å±€' ? 'å¹³å±€' : w + 'è·èƒœï¼'}`);
                window.SoundManager.playSound('victory');
                setWinner(w);
            } else {
                logs.push('æˆ˜æ–—ç»“ç®—å®Œæˆ');
            }
            
            setGameState(prev => ({
                ...prev,
                phase: 'idle',
                red: {
                    ...prev.red,
                    battlefield: redBF,
                    health: redHP,
                    hand: redHand,
                    miracleDrawn: redDrawn
                },
                blue: {
                    ...prev.blue,
                    battlefield: blueBF,
                    health: blueHP,
                    hand: blueHand,
                    miracleDrawn: blueDrawn
                },
                miracleDeck: newMDeck,
                discardPile: discard,
                log: [...prev.log, ...logs]
            }));
            
            setTimeout(() => {
                const currentState = gameStateRef.current;
                if (currentState.deck.length === 0 && 
                    currentState.red.hand.length === 0 && 
                    currentState.blue.hand.length === 0 && 
                    !winner) {
                    const w = currentState.red.health > currentState.blue.health ? 'çº¢æ–¹' : 
                             (currentState.blue.health > currentState.red.health ? 'è“æ–¹' : 'å¹³å±€');
                    setWinner(w);
                    window.SoundManager.playSound('victory');
                    setGameState(prev => ({
                        ...prev,
                        log: [...prev.log, 'ç‰Œåº“è€—å°½', `${w === 'å¹³å±€' ? 'å¹³å±€' : w + 'è·èƒœ'}`]
                    }));
                }
            }, 100);
        };

        const reset = () => {
            setWinner(null);
            setGamePhase('notStarted');
            setBattleAnimation({ active: false, lane: -1 });
            setGameState(INIT_STATE);
            myPickCountRef.current = 0;
            opponentPickedRef.current = false;
            gameManagerRef.current.isReady = false;
            setRoomPlayers(prev => prev.map(p => ({ ...p, ready: false })));
            setScreen('room');
        };

        if (!uiReady) {
            return <div className="text-white text-center mt-40 text-xl">åŠ è½½ä¸­â€¦</div>;
        }

        if (showReconnectPrompt) {
            return (
                <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-blue-900 flex items-center justify-center p-4">
                    <div className="max-w-md w-full bg-gray-800 rounded-2xl p-8 shadow-2xl border-2 border-yellow-500">
                        <div className="text-center mb-6">
                            <div className="text-6xl mb-4">ğŸ”„</div>
                            <h2 className="text-3xl font-bold text-white mb-2">æ£€æµ‹åˆ°æ–­çº¿</h2>
                            <p className="text-gray-300">å‘ç°æœªå®Œæˆçš„æ¸¸æˆ</p>
                        </div>
                        <div className="bg-gray-700 rounded-xl p-4 mb-6">
                            <div className="text-sm text-gray-300 mb-2">æˆ¿é—´</div>
                            <div className="text-2xl font-bold text-yellow-400 font-mono">
                                {reconnectData?.roomId}
                            </div>
                            <div className="text-sm text-gray-400 mt-2">
                                èº«ä»½: {reconnectData?.playerSide === 'red' ? 'çº¢æ–¹ğŸ”´' : 'è“æ–¹ğŸ”µ'}
                            </div>
                        </div>
                        <div className="grid gap-3">
                            <button onClick={handleReconnect} className="w-full py-4 bg-green-600 hover:bg-green-700 text-white rounded-xl font-bold text-lg transition-all">
                                é‡æ–°è¿æ¥
                            </button>
                            <button onClick={handleNewGame} className="w-full py-4 bg-gray-600 hover:bg-gray-700 text-white rounded-xl font-bold text-lg transition-all">
                                å¼€å§‹æ–°æ¸¸æˆ
                            </button>
                        </div>
                    </div>
                </div>
            );
        }

        if (screen === 'lobby') {
            return (
                <div className="min-h-screen bg-gradient-to-br from-slate-900 via-blue-900 to-purple-900 flex items-center justify-center p-4">
                    <div className="max-w-4xl w-full">
                        <div className="text-center mb-12">
                            <h1 className="text-6xl font-bold text-white mb-4 drop-shadow-lg">
                                ğŸŒ åœ¨çº¿å¯¹æˆ˜å¤§å…
                            </h1>
                            <p className="text-xl text-gray-300">é€‰æ‹©ä¸€ä¸ªæˆ¿é—´å¼€å§‹æ¸¸æˆ</p>
                        </div>
                        <div className="grid grid-cols-2 md:grid-cols-3 gap-4 mb-8">
                            {ROOMS.map(roomId => (
                                <button
                                    key={roomId}
                                    onClick={() => handleJoinRoom(roomId)}
                                    onMouseEnter={() => window.SoundManager.playSound('hover')}
                                    className="bg-gradient-to-br from-purple-600 to-blue-600 rounded-xl p-6 text-white hover:scale-105 transition-all duration-200 shadow-lg"
                                >
                                    <div className="text-4xl mb-2">ğŸšª</div>
                                    <div className="text-2xl font-bold mb-1">{roomId.toUpperCase()}</div>
                                    <div className="text-sm text-gray-200">ç‚¹å‡»åŠ å…¥</div>
                                </button>
                            ))}
                        </div>
                        <div className="text-center">
                            <button onClick={() => { window.SoundManager.playSound('click'); window.location.href = 'index.html'; }} className="px-8 py-4 bg-gray-700 hover:bg-gray-600 text-white rounded-xl font-bold text-xl transition-all">
                                è¿”å›ä¸»ç•Œé¢
                            </button>
                        </div>
                        <div className="mt-8 text-center text-gray-400 text-sm">
                            <p>ğŸ’¡ é€‰æ‹©æˆ¿é—´åç­‰å¾…å¯¹æ‰‹ï¼ŒåŒæ–¹å‡†å¤‡å³å¯å¼€å§‹</p>
                            <p className="mt-2">ğŸ”„ æ”¯æŒæ–­çº¿é‡è¿</p>
                        </div>
                    </div>
                </div>
            );
        }

        if (screen === 'room') {
            const myPlayer = roomPlayers.find(p => p.playerId === gameManagerRef.current.playerId);
            const opponentPlayer = roomPlayers.find(p => p.playerId !== gameManagerRef.current.playerId);
            return (
                <div className="min-h-screen bg-gradient-to-br from-slate-900 via-blue-900 to-purple-900 flex items-center justify-center p-4">
                    <div className="max-w-2xl w-full">
                        <div className="bg-gray-800 rounded-2xl p-8 shadow-2xl">
                            <div className="text-center mb-8">
                                <h2 className="text-4xl font-bold text-white mb-2">
                                    å‡†å¤‡å®¤ - {currentRoomId?.toUpperCase()}
                                </h2>
                                <p className="text-gray-300">ç­‰å¾…ç©å®¶å‡†å¤‡</p>
                            </div>
                            <div className="grid grid-cols-2 gap-4 mb-8">
                                <div className={`border-2 rounded-xl p-6 text-center ${myPlayer?.ready ? 'bg-green-900/30 border-green-500' : 'bg-gray-700/30 border-gray-500'}`}>
                                    <div className="text-2xl mb-2">ğŸ‘¤</div>
                                    <div className="text-white font-bold mb-1">ä½ </div>
                                    <div className={`text-sm ${myPlayer?.ready ? 'text-green-400' : 'text-yellow-400'}`}>
                                        {myPlayer?.ready ? 'âœ“ å·²å‡†å¤‡' : 'æœªå‡†å¤‡'}
                                    </div>
                                </div>
                                <div className={`border-2 rounded-xl p-6 text-center ${opponentPlayer?.ready ? 'bg-green-900/30 border-green-500' : 'bg-gray-700/30 border-gray-500'}`}>
                                    <div className="text-2xl mb-2">{opponentPlayer ? 'ğŸ‘¤' : 'â³'}</div>
                                    <div className="text-white font-bold mb-1">{opponentPlayer ? 'å¯¹æ‰‹' : 'ç­‰å¾…ä¸­...'}</div>
                                    <div className={`text-sm ${opponentPlayer?.ready ? 'text-green-400' : 'text-yellow-400'}`}>
                                        {opponentPlayer ? (opponentPlayer.ready ? 'âœ“ å·²å‡†å¤‡' : 'æœªå‡†å¤‡') : 'ç­‰å¾…åŠ å…¥'}
                                    </div>
                                </div>
                            </div>
                            <div className="flex gap-4">
                                <button onClick={handleToggleReady} disabled={!opponentPlayer} className={`flex-1 py-4 rounded-xl font-bold text-xl transition-all ${!opponentPlayer ? 'bg-gray-600 text-gray-400 cursor-not-allowed' : (myPlayer?.ready ? 'bg-yellow-600 hover:bg-yellow-700 text-white' : 'bg-green-600 hover:bg-green-700 text-white')}`}>
                                    {myPlayer?.ready ? 'å–æ¶ˆå‡†å¤‡' : 'å‡†å¤‡'}
                                </button>
                                <button onClick={handleLeaveRoom} className="px-8 py-4 bg-red-600 hover:bg-red-700 text-white rounded-xl font-bold text-xl transition-all">
                                    ç¦»å¼€
                                </button>
                            </div>
                            {canStartGame && (
                                <div className="mt-6 text-center">
                                    <div className="inline-block px-6 py-3 bg-green-600 rounded-lg animate-pulse">
                                        <span className="text-white font-bold">åŒæ–¹å·²å‡†å¤‡ï¼Œå³å°†å¼€å§‹æŠ½ç­¾...</span>
                                    </div>
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        }

        if (screen === 'roulette' && showRoulette) {
            return (
                <div className="fixed inset-0 bg-black bg-opacity-90 z-[200] flex items-center justify-center">
                    <div className="text-center">
                        <h1 className="text-4xl font-bold text-white mb-8">çº¢è“æŠ½ç­¾ä¸­...</h1>
                        <div className="relative w-64 h-64 mx-auto">
                            <div className="absolute inset-0 rounded-full border-8 border-gray-700 overflow-hidden animate-spin" style={{ animationDuration: '0.5s' }}>
                                <div className="absolute top-0 left-0 w-full h-1/2 bg-red-600"></div>
                                <div className="absolute bottom-0 left-0 w-full h-1/2 bg-blue-600"></div>
                            </div>
                            <div className="absolute inset-0 flex items-center justify-center">
                                <div className="w-4 h-20 bg-yellow-400 rounded-full shadow-2xl" style={{ transform: 'translateY(-60px)' }}></div>
                            </div>
                        </div>
                        {rouletteResult && (
                            <div className="mt-8 text-3xl font-bold animate-pulse text-white">
                                {rouletteResult === 'red' ? 'ğŸ”´ ä½ æ˜¯çº¢æ–¹ï¼' : 'ğŸ”µ ä½ æ˜¯è“æ–¹ï¼'}
                            </div>
                        )}
                    </div>
                </div>
            );
        }

        if (screen === 'game') {
            if (!window.GameUI) {
                return <div className="text-white text-center mt-40 text-xl">æ¸¸æˆUIæœªåŠ è½½â€¦</div>;
            }

            const mySide = gameManagerRef.current?.playerSide;
            const opponentOnline = roomPlayers.length === 2;

            return (
                <window.GameUI
                    gameState={gameState}
                    gamePhase={gamePhase}
                    allCards={allCards}
                    winner={winner}
                    battleAnimation={battleAnimation}
                    cardShowOverlay={cardShowOverlay}
                    onStartPicking={() => {}}
                    onPickCard={pickCard}
                    onStartTurn={startTurn}
                    onSelectCard={selectCard}
                    onPlayCard={playCard}
                    onUseCardOnTarget={useCardOnTarget}
                    onConfirmUse={confirmUse}
                    onEndPhase={endPhase}
                    onReset={reset}
                    hideOpponentHand={true}
                    myRole={mySide}
                    extraUI={
                        <div className="fixed bottom-4 left-4 md:top-4 md:bottom-auto md:right-4 md:left-auto z-50 bg-gray-800 rounded-lg p-2 md:p-3 shadow-lg border-2 border-purple-500">
                            <div className="text-white text-xs md:text-sm">
                                <div className="font-bold mb-1">ğŸŒ åœ¨çº¿å¯¹æˆ˜</div>
                                <div className="text-yellow-400 font-mono text-[10px] md:text-xs">
                                    æˆ¿é—´: {currentRoomId?.toUpperCase()}
                                </div>
                                <div className={`text-[10px] md:text-xs mt-1 flex items-center gap-1 ${opponentOnline ? 'text-green-400' : 'text-red-400'}`}>
                                    <div className={`w-2 h-2 rounded-full ${opponentOnline ? 'bg-green-500 animate-pulse' : 'bg-red-500'}`}></div>
                                    {opponentOnline ? 'å¯¹æ‰‹åœ¨çº¿' : 'å¯¹æ‰‹ç¦»çº¿'}
                                </div>
                                <button onClick={handleBackToLobby} className="mt-2 w-full px-2 py-1 bg-red-600 hover:bg-red-700 rounded text-[10px] md:text-xs transition-all">
                                    é€€å‡ºæ¸¸æˆ
                                </button>
                            </div>
                        </div>
                    }
                />
            );
        }

        return null;
    };

    ReactDOM.render(<OnlineGame />, document.getElementById('root'));
    </script>
</body>
</html>
