<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å››è·¯çº¿å¡ç‰Œå¯¹æˆ˜ â€” åœ¨çº¿å¯¹æˆ˜</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="https://cdn.pubnub.com/sdk/javascript/pubnub.7.4.0.js"></script>
    <script src="shared.js"></script>
    <script src="cardEffects.js"></script>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
    const { useState, useEffect, useCallback, useRef } = React;

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // PubNub é…ç½®
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const PUBNUB_CONFIG = {
        publishKey: 'pub-c-f4e44d70-cc7d-4f6b-a8f3-cf3a93b39a0a',
        subscribeKey: 'sub-c-c4597e4a-cee9-4265-b2d7-136bb547facb',
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // æ–­çº¿é‡è¿ - LocalStorage ç®¡ç†
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const ReconnectManager = {
        STORAGE_KEY: 'cardgame_online_session',
        
        saveSession(data) {
            try {
                localStorage.setItem(this.STORAGE_KEY, JSON.stringify({
                    ...data,
                    timestamp: Date.now()
                }));
            } catch (e) {
                console.error('[ReconnectManager] ä¿å­˜å¤±è´¥:', e);
            }
        },
        
        loadSession() {
            try {
                const data = localStorage.getItem(this.STORAGE_KEY);
                if (!data) return null;
                
                const session = JSON.parse(data);
                const age = Date.now() - session.timestamp;
                
                if (age > 30 * 60 * 1000) {
                    this.clearSession();
                    return null;
                }
                
                return session;
            } catch (e) {
                console.error('[ReconnectManager] åŠ è½½å¤±è´¥:', e);
                return null;
            }
        },
        
        clearSession() {
            localStorage.removeItem(this.STORAGE_KEY);
        }
    };

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // åœ¨çº¿æ¸¸æˆç®¡ç†å™¨
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    class OnlineGameManager {
        constructor() {
            this.pubnub = null;
            this.roomId = null;
            this.playerId = null;
            this.playerSide = null;
            this.isHost = false;
            this.onMessageCallback = null;
            this.onPresenceCallback = null;
            this.heartbeatInterval = null;
        }

        init(existingPlayerId = null) {
            this.playerId = existingPlayerId || 'player_' + Math.random().toString(36).substr(2, 9);
            this.pubnub = new PubNub({
                ...PUBNUB_CONFIG,
                uuid: this.playerId,
                heartbeatInterval: 10
            });
            console.log('[GameManager] åˆå§‹åŒ– playerId:', this.playerId);
        }

        createRoom() {
            this.roomId = this.generateRoomId();
            this.isHost = true;
            this.playerSide = 'red';
            this.subscribeToRoom();
            this.startHeartbeat();
            return this.roomId;
        }

        joinRoom(roomId) {
            this.roomId = roomId;
            this.isHost = false;
            this.playerSide = 'blue';
            this.subscribeToRoom();
            this.startHeartbeat();
            this.sendMessage({ type: 'player-joined', playerId: this.playerId });
        }

        rejoinRoom(roomId, isHost, playerSide) {
            this.roomId = roomId;
            this.isHost = isHost;
            this.playerSide = playerSide;
            this.subscribeToRoom();
            this.startHeartbeat();
            this.sendMessage({ 
                type: 'player-rejoined', 
                playerId: this.playerId,
                playerSide: this.playerSide
            });
        }

        subscribeToRoom() {
            if (!this.pubnub || !this.roomId) return;

            this.pubnub.addListener({
                message: (event) => {
                    if (event.message.senderId !== this.playerId && this.onMessageCallback) {
                        this.onMessageCallback(event.message);
                    }
                },
                presence: (event) => {
                    if (this.onPresenceCallback) {
                        this.onPresenceCallback(event);
                    }
                }
            });

            this.pubnub.subscribe({
                channels: [this.roomId],
                withPresence: true
            });
        }

        sendMessage(message) {
            if (!this.pubnub || !this.roomId) return;
            
            this.pubnub.publish({
                channel: this.roomId,
                message: {
                    ...message,
                    senderId: this.playerId,
                    timestamp: Date.now()
                }
            });
        }

        startHeartbeat() {
            this.heartbeatInterval = setInterval(() => {
                this.sendMessage({ type: 'heartbeat' });
            }, 30000);
        }

        leaveRoom() {
            if (this.heartbeatInterval) {
                clearInterval(this.heartbeatInterval);
            }
            if (this.pubnub && this.roomId) {
                this.sendMessage({ type: 'player-left' });
                this.pubnub.unsubscribe({
                    channels: [this.roomId]
                });
            }
        }

        generateRoomId() {
            return Math.random().toString(36).substr(2, 6).toUpperCase();
        }

        setMessageCallback(callback) {
            this.onMessageCallback = callback;
        }

        setPresenceCallback(callback) {
            this.onPresenceCallback = callback;
        }
    }

    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    // ä¸»åº”ç”¨ç»„ä»¶
    // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    const OnlineGame = () => {
        const [uiReady, setUiReady] = useState(false);
        const [allCards, setAllCards] = useState([]);
        
        useEffect(() => { 
            window.GameUILoader.load().then(() => setUiReady(true)); 
            window.SoundManager.restoreFromStorage(); 
        }, []);

        useEffect(() => { 
            window.loadCards().then(cards => setAllCards(cards)).catch(err => { 
                console.error('åŠ è½½å¡ç‰Œå¤±è´¥', err); 
                alert('æ— æ³•åŠ è½½ card_data.csv'); 
            }); 
        }, []);

        const INIT_STATE = {
            turn: 0, phase: 'idle',
            red: { health: 30, coins: 0, hand: [], battlefield: [null,null,null,null], miracleDrawn: [30] },
            blue: { health: 30, coins: 0, hand: [], battlefield: [null,null,null,null], miracleDrawn: [30] },
            deck: [], miracleDeck: [], discardPile: [], initialCards: [], initialCardsBlue: [], selectedCard: null, log: []
        };

        const [screen, setScreen] = useState('menu');
        const [roomId, setRoomId] = useState('');
        const [roomInput, setRoomInput] = useState('');
        const gameManagerRef = useRef(null);
        const [opponentConnected, setOpponentConnected] = useState(false);
        const [showReconnectPrompt, setShowReconnectPrompt] = useState(false);
        const [reconnectData, setReconnectData] = useState(null);

        const [gameState, setGameState] = useState(INIT_STATE);
        const gameStateRef = useRef(gameState);
        const [gamePhase, setGamePhase] = useState('notStarted');
        const [winner, setWinner] = useState(null);
        const [battleAnimation, setBattleAnimation] = useState({ active: false, lane: -1 });
        const [cardShowOverlay, setCardShowOverlay] = useState(null);

        useEffect(() => {
            gameManagerRef.current = new OnlineGameManager();
            
            const session = ReconnectManager.loadSession();
            if (session && session.roomId) {
                setReconnectData(session);
                setShowReconnectPrompt(true);
            }
            
            return () => {
                if (gameManagerRef.current) {
                    gameManagerRef.current.leaveRoom();
                }
            };
        }, []);

        useEffect(() => {
            gameStateRef.current = gameState;
        }, [gameState]);

        const handleReconnect = () => {
            if (!reconnectData) return;
            
            gameManagerRef.current.init(reconnectData.playerId);
            gameManagerRef.current.rejoinRoom(
                reconnectData.roomId,
                reconnectData.isHost,
                reconnectData.playerSide
            );
            
            setRoomId(reconnectData.roomId);
            setGameState(reconnectData.gameState || INIT_STATE);
            setGamePhase(reconnectData.gamePhase || 'notStarted');
            
            setScreen(reconnectData.gamePhase === 'notStarted' ? 'lobby' : 'game');
            setShowReconnectPrompt(false);
            window.SoundManager.playSound('click');
        };

        const handleNewGame = () => {
            ReconnectManager.clearSession();
            setShowReconnectPrompt(false);
            window.SoundManager.playSound('click');
        };

        const addLog = useCallback((msg) => { 
            setGameState(prev => ({ ...prev, log: [...prev.log, msg] })); 
        }, []);

        const showCardOverlay = useCallback((card) => {
            setCardShowOverlay(card);
            const dur = card.type === 'miracle' ? 2000 : 1000;
            window.SoundManager.playSound(card.type === 'miracle' ? 'miracle' : 'place');
            setTimeout(() => setCardShowOverlay(null), dur);
        }, []);

        useEffect(() => {
            if ((screen === 'game' || screen === 'lobby') && gameManagerRef.current) {
                ReconnectManager.saveSession({
                    roomId,
                    playerId: gameManagerRef.current.playerId,
                    playerSide: gameManagerRef.current.playerSide,
                    isHost: gameManagerRef.current.isHost,
                    gameState,
                    gamePhase,
                    screen
                });
            }
        }, [gameState, gamePhase, screen, roomId]);

        const handleNetworkMessage = useCallback((message) => {
            switch (message.type) {
                case 'player-joined':
                case 'player-rejoined':
                    setOpponentConnected(true);
                    window.SoundManager.playSound('click');
                    if (message.type === 'player-rejoined') {
                        addLog('å¯¹æ‰‹å·²é‡æ–°è¿æ¥');
                    }
                    break;
                
                case 'player-left':
                    setOpponentConnected(false);
                    addLog('âš ï¸ å¯¹æ‰‹å·²ç¦»å¼€æˆ¿é—´');
                    break;
                
                case 'heartbeat':
                    setOpponentConnected(true);
                    break;
                
                case 'start-game':
                    if (gameManagerRef.current?.playerSide === 'blue') {
                        initializeGameWithSeed(message.seed);
                    }
                    break;

                case 'pick-card': handleRemotePickCard(message.card); break;
                case 'play-card': handleRemotePlayCard(message.card, message.laneIndex); break;
                case 'use-support': handleRemoteUseSupport(message.card, message.targetPlayer, message.laneIndex); break;
                case 'confirm-use': handleRemoteConfirmUse(message.card); break;
                case 'end-phase': handleRemoteEndPhase(); break;
                case 'start-turn': handleRemoteStartTurn(); break;
                case 'sync-state':
                    if (message.gameState && message.gamePhase) {
                        setGameState(message.gameState);
                        setGamePhase(message.gamePhase);
                        if (message.winner) setWinner(message.winner);
                    }
                    break;
            }
        }, [addLog]);

        useEffect(() => {
            if (!gameManagerRef.current) return;

            gameManagerRef.current.setMessageCallback((message) => {
                handleNetworkMessage(message);
            });

            gameManagerRef.current.setPresenceCallback((event) => {
                if (event.uuid !== gameManagerRef.current.playerId) {
                    if (event.action === 'join' || event.action === 'state-change') {
                        setOpponentConnected(true);
                        window.SoundManager.playSound('click');
                    } else if (event.action === 'leave' || event.action === 'timeout') {
                        setOpponentConnected(false);
                        addLog('âš ï¸ å¯¹æ‰‹å·²ç¦»å¼€æˆ¿é—´');
                    }
                }
            });
        }, [handleNetworkMessage, addLog]);

        const handleCreateRoom = () => {
            if (!gameManagerRef.current.pubnub) {
                gameManagerRef.current.init();
            }
            const newRoomId = gameManagerRef.current.createRoom();
            setRoomId(newRoomId);
            setScreen('lobby');
            window.SoundManager.playSound('click');
        };

        const handleJoinRoom = () => {
            if (!roomInput.trim()) {
                alert('è¯·è¾“å…¥æˆ¿é—´å·ï¼');
                return;
            }
            if (!gameManagerRef.current.pubnub) {
                gameManagerRef.current.init();
            }
            gameManagerRef.current.joinRoom(roomInput.toUpperCase());
            setRoomId(roomInput.toUpperCase());
            setScreen('lobby');
            window.SoundManager.playSound('click');
        };

        const handleStartGame = () => {
            if (!opponentConnected) {
                alert('ç­‰å¾…å¯¹æ‰‹åŠ å…¥æˆ¿é—´ï¼');
                return;
            }
            
            const seed = Date.now();
            gameManagerRef.current.sendMessage({ type: 'start-game', seed });
            initializeGameWithSeed(seed);
            window.SoundManager.playSound('click');
        };

        const handleBackToLobby = () => {
            if (confirm('ç¡®å®šè¦ç¦»å¼€æ¸¸æˆå—ï¼Ÿè¿›åº¦å°†ä¼šä¸¢å¤±ã€‚')) {
                gameManagerRef.current.leaveRoom();
                ReconnectManager.clearSession();
                setScreen('menu');
                setRoomId('');
                setOpponentConnected(false);
                setGameState(INIT_STATE);
                setGamePhase('notStarted');
                setWinner(null);
                window.SoundManager.playSound('click');
            }
        };

        const initializeGameWithSeed = (seed) => {
            if (!allCards || allCards.length === 0) return;

            const seededRandom = (s) => {
                const x = Math.sin(s++) * 10000;
                return x - Math.floor(x);
            };

            let currentSeed = seed;
            const seededShuffle = (arr) => {
                const a = [...arr];
                for (let i = a.length - 1; i > 0; i--) {
                    const j = Math.floor(seededRandom(currentSeed++) * (i + 1));
                    [a[i], a[j]] = [a[j], a[i]];
                }
                return a;
            };

            const regular = allCards.filter(c => c.type !== 'miracle');
            const miracles = allCards.filter(c => c.type === 'miracle');
            const deck = seededShuffle(regular.map(window.createCard));
            const miracleDeck = seededShuffle(miracles.map(window.createCard));

            const redSix = deck.slice(0, 6);
            const blueSix = deck.slice(6, 12);
            const rest = deck.slice(12);

            const mDeck = [...miracleDeck];
            const redM = mDeck.pop();
            const blueM = mDeck.pop();

            setGameState({
                ...INIT_STATE,
                red: { ...INIT_STATE.red, hand: redM ? [redM] : [] },
                blue: { ...INIT_STATE.blue, hand: blueM ? [blueM] : [] },
                deck: rest,
                miracleDeck: mDeck,
                initialCards: redSix,
                initialCardsBlue: blueSix,
                log: [
                    'ğŸŒ åœ¨çº¿æ¸¸æˆå¼€å§‹ï¼',
                    `ä½ æ˜¯${gameManagerRef.current.playerSide === 'red' ? 'çº¢æ–¹ğŸ”´' : 'è“æ–¹ğŸ”µ'}',
                    'åŒæ–¹å„æŠ½å–1å¼ å¥‡è¿¹ç‰Œ',
                    '--- é€‰ç‰Œé˜¶æ®µå¼€å§‹ ---'
                ]
            });
            setGamePhase('redPicking');
            setScreen('game');
        };

        const pickCard = (card) => {
            const phase = gamePhase;
            const isMyTurn = (phase === 'redPicking' && gameManagerRef.current.playerSide === 'red') || 
                            (phase === 'bluePicking' && gameManagerRef.current.playerSide === 'blue');
            if (!isMyTurn) return;

            window.SoundManager.playSound('click');
            gameManagerRef.current.sendMessage({ type: 'pick-card', card });

            if (phase === 'redPicking') {
                setGameState(prev => {
                    const newHand = [...prev.red.hand, card];
                    const remaining = prev.initialCards.filter(c => c.instanceId !== card.instanceId);
                    if (newHand.length === 3) {
                        setGamePhase('bluePicking');
                        return {
                            ...prev,
                            red: { ...prev.red, hand: newHand },
                            initialCards: prev.initialCardsBlue,
                            deck: window.shuffleArray([...prev.deck, ...remaining]),
                            log: [...prev.log, 'çº¢æ–¹é€‰ç‰Œå®Œæˆ']
                        };
                    } else {
                        return {
                            ...prev,
                            red: { ...prev.red, hand: newHand },
                            initialCards: remaining,
                            log: [...prev.log, `çº¢æ–¹é€‰æ‹©äº† ${card.name}`]
                        };
                    }
                });
            } else if (phase === 'bluePicking') {
                setGameState(prev => {
                    const newHand = [...prev.blue.hand, card];
                    const remaining = prev.initialCards.filter(c => c.instanceId !== card.instanceId);
                    if (newHand.length === 3) {
                        setGamePhase('playing');
                        return {
                            ...prev,
                            blue: { ...prev.blue, hand: newHand },
                            initialCards: [],
                            deck: window.shuffleArray([...prev.deck, ...remaining]),
                            log: [...prev.log, 'è“æ–¹é€‰ç‰Œå®Œæˆ â†’ é€‰ç‰Œé˜¶æ®µç»“æŸ']
                        };
                    } else {
                        return {
                            ...prev,
                            blue: { ...prev.blue, hand: newHand },
                            initialCards: remaining,
                            log: [...prev.log, `è“æ–¹é€‰æ‹©äº† ${card.name}`]
                        };
                    }
                });
            }
        };

        const handleRemotePickCard = (card) => {
            const phase = gamePhase;
            const opponentSide = gameManagerRef.current.playerSide === 'red' ? 'blue' : 'red';
            const isOpponentTurn = (phase === 'redPicking' && opponentSide === 'red') || 
                                  (phase === 'bluePicking' && opponentSide === 'blue');
            if (!isOpponentTurn) return;

            if (phase === 'redPicking') {
                setGameState(prev => {
                    const newHand = [...prev.red.hand, card];
                    const remaining = prev.initialCards.filter(c => c.instanceId !== card.instanceId);
                    if (newHand.length === 3) {
                        setGamePhase('bluePicking');
                        return {
                            ...prev,
                            red: { ...prev.red, hand: newHand },
                            initialCards: prev.initialCardsBlue,
                            deck: window.shuffleArray([...prev.deck, ...remaining]),
                            log: [...prev.log, 'çº¢æ–¹é€‰ç‰Œå®Œæˆ']
                        };
                    } else {
                        return {
                            ...prev,
                            red: { ...prev.red, hand: newHand },
                            initialCards: remaining,
                            log: [...prev.log, `çº¢æ–¹é€‰æ‹©äº† ${card.name}`]
                        };
                    }
                });
            } else if (phase === 'bluePicking') {
                setGameState(prev => {
                    const newHand = [...prev.blue.hand, card];
                    const remaining = prev.initialCards.filter(c => c.instanceId !== card.instanceId);
                    if (newHand.length === 3) {
                        setGamePhase('playing');
                        return {
                            ...prev,
                            blue: { ...prev.blue, hand: newHand },
                            initialCards: [],
                            deck: window.shuffleArray([...prev.deck, ...remaining]),
                            log: [...prev.log, 'è“æ–¹é€‰ç‰Œå®Œæˆ â†’ é€‰ç‰Œé˜¶æ®µç»“æŸ']
                        };
                    } else {
                        return {
                            ...prev,
                            blue: { ...prev.blue, hand: newHand },
                            initialCards: remaining,
                            log: [...prev.log, `è“æ–¹é€‰æ‹©äº† ${card.name}`]
                        };
                    }
                });
            }
        };

        const startTurn = () => {
            if (gameManagerRef.current.playerSide !== 'red') return;
            gameManagerRef.current.sendMessage({ type: 'start-turn' });
            doStartTurn();
        };

        const handleRemoteStartTurn = () => {
            doStartTurn();
        };

        const doStartTurn = () => {
            setGameState(prev => {
                const newTurn = prev.turn + 1;
                const coins = Math.min(newTurn, 10);
                const logs = [`--- ç¬¬${newTurn}å›åˆå¼€å§‹ ---`, `åŒæ–¹è·å¾— ${coins} é‡‘å¸`];
                
                let deck = [...prev.deck];
                let redHand = [...prev.red.hand];
                let blueHand = [...prev.blue.hand];

                if (newTurn >= 2) {
                    for (let i = 0; i < 2; i++) {
                        const r = deck.pop();
                        if (r) redHand.push(r);
                        const b = deck.pop();
                        if (b) blueHand.push(b);
                    }
                    logs.push('åŒæ–¹å„æŠ½2å¼ ç‰Œ');
                } else {
                    logs.push('ç¬¬ä¸€å›åˆä¸æŠ½ç‰Œ');
                }

                return {
                    ...prev,
                    turn: newTurn,
                    phase: 'redDeploy',
                    deck,
                    red: { ...prev.red, coins, hand: redHand },
                    blue: { ...prev.blue, coins, hand: blueHand },
                    log: [...prev.log, ...logs]
                };
            });
        };

        const selectCard = (card, player) => {
            const phase = gameStateRef.current.phase;
            if (player !== gameManagerRef.current.playerSide || phase === 'idle' || phase === 'battle') return;
            const isRedPhase = phase === 'redDeploy' || phase === 'redSupport';
            if ((isRedPhase && player !== 'red') || (!isRedPhase && player !== 'blue')) return;
            
            setGameState(prev => {
                if (prev.selectedCard?.instanceId === card.instanceId) {
                    return { ...prev, selectedCard: null };
                }
                return { ...prev, selectedCard: card };
            });
        };

        const playCard = (laneIndex) => {
            const state = gameStateRef.current;
            const card = state.selectedCard;
            if (!card || card.type !== 'battlefield') return;
            
            const phase = state.phase;
            const player = (phase === 'redDeploy' || phase === 'redSupport') ? 'red' : 'blue';
            if (player !== gameManagerRef.current.playerSide) return;

            const playerState = state[player];
            if (playerState.coins < card.cost) {
                addLog('é‡‘å¸ä¸è¶³ï¼');
                return;
            }
            if (playerState.battlefield[laneIndex] !== null) {
                addLog('è¯¥è·¯çº¿å·²æœ‰å¡ç‰Œï¼');
                return;
            }

            window.SoundManager.playSound('place');
            gameManagerRef.current.sendMessage({ type: 'play-card', card, laneIndex });

            setGameState(prev => {
                const bf = [...prev[player].battlefield];
                bf[laneIndex] = { ...card };
                return {
                    ...prev,
                    [player]: {
                        ...prev[player],
                        battlefield: bf,
                        hand: prev[player].hand.filter(c => c.instanceId !== card.instanceId),
                        coins: prev[player].coins - card.cost
                    },
                    selectedCard: null,
                    log: [...prev.log, `${player === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}åœ¨è·¯çº¿${laneIndex+1}æ”¾ç½®äº† ${card.name}`]
                };
            });
        };

        const handleRemotePlayCard = (card, laneIndex) => {
            const state = gameStateRef.current;
            const phase = state.phase;
            const player = (phase === 'redDeploy' || phase === 'redSupport') ? 'red' : 'blue';
            if (player === gameManagerRef.current.playerSide) return;

            setGameState(prev => {
                const bf = [...prev[player].battlefield];
                bf[laneIndex] = { ...card };
                return {
                    ...prev,
                    [player]: {
                        ...prev[player],
                        battlefield: bf,
                        hand: prev[player].hand.filter(c => c.instanceId !== card.instanceId),
                        coins: prev[player].coins - card.cost
                    },
                    log: [...prev.log, `${player === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}åœ¨è·¯çº¿${laneIndex+1}æ”¾ç½®äº† ${card.name}`]
                };
            });
        };

        const useCardOnTarget = (targetPlayer, laneIndex) => {
            const state = gameStateRef.current;
            const card = state.selectedCard;
            if (!card || (card.type !== 'support' && card.type !== 'miracle')) return;
            
            const phase = state.phase;
            const player = (phase === 'redDeploy' || phase === 'redSupport') ? 'red' : 'blue';
            if (player !== gameManagerRef.current.playerSide) return;

            const playerState = state[player];
            const target = state[targetPlayer].battlefield[laneIndex];
            
            const needsTarget = window.EffectEngine?.needsTarget(card.id) || false;
            if (needsTarget && !target) {
                addLog('ç›®æ ‡ä½ç½®æ²¡æœ‰å•ä½ï¼');
                return;
            }

            const cost = card.type === 'miracle' ? 0 : card.cost;
            if (playerState.coins < cost) {
                addLog('é‡‘å¸ä¸è¶³ï¼');
                return;
            }

            gameManagerRef.current.sendMessage({ 
                type: 'use-support', 
                card, 
                targetPlayer, 
                laneIndex,
                needsTarget 
            });

            applyCardEffect(card, player, target);
        };

        const handleRemoteUseSupport = (card, targetPlayer, laneIndex) => {
            const state = gameStateRef.current;
            const phase = state.phase;
            const player = (phase === 'redDeploy' || phase === 'redSupport') ? 'red' : 'blue';
            if (player === gameManagerRef.current.playerSide) return;

            const needsTarget = window.EffectEngine?.needsTarget(card.id) || false;
            const target = needsTarget ? state[targetPlayer].battlefield[laneIndex] : null;
            applyCardEffect(card, player, target);
        };

        const confirmUse = () => {
            const state = gameStateRef.current;
            const card = state.selectedCard;
            if (!card) return;
            
            const phase = state.phase;
            const player = (phase === 'redDeploy' || phase === 'redSupport') ? 'red' : 'blue';
            if (player !== gameManagerRef.current.playerSide) return;

            const playerState = state[player];
            const cost = card.type === 'miracle' ? 0 : card.cost;
            if (playerState.coins < cost) {
                addLog('é‡‘å¸ä¸è¶³ï¼');
                return;
            }

            gameManagerRef.current.sendMessage({ type: 'confirm-use', card });
            applyCardEffect(card, player, null);
        };

        const handleRemoteConfirmUse = (card) => {
            const state = gameStateRef.current;
            const phase = state.phase;
            const player = (phase === 'redDeploy' || phase === 'redSupport') ? 'red' : 'blue';
            if (player === gameManagerRef.current.playerSide) return;

            applyCardEffect(card, player, null);
        };

        const applyCardEffect = (card, player, target) => {
            const cost = card.type === 'miracle' ? 0 : card.cost;
            showCardOverlay(card);

            setGameState(prev => {
                let newState = {
                    ...prev,
                    [player]: {
                        ...prev[player],
                        hand: prev[player].hand.filter(c => c.instanceId !== card.instanceId),
                        coins: prev[player].coins - cost
                    },
                    discardPile: [...prev.discardPile, card]
                };

                if (window.EffectEngine) {
                    try {
                        const context = {
                            player: player,
                            card: card,
                            target: target,
                            logCallback: (msg) => {
                                newState.log = [...newState.log, msg];
                            }
                        };

                        const resultState = window.EffectEngine.trigger(card.id, context, newState);
                        
                        return {
                            ...resultState,
                            selectedCard: null
                        };
                    } catch (error) {
                        console.error('[applyCardEffect] æ•ˆæœæ‰§è¡Œå¤±è´¥:', error);
                        newState.log = [...newState.log, `${player === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}ä½¿ç”¨äº† ${card.name}`];
                    }
                } else {
                    newState.log = [...newState.log, `${player === 'red' ? 'çº¢æ–¹' : 'è“æ–¹'}ä½¿ç”¨äº† ${card.name}`];
                }

                return {
                    ...newState,
                    selectedCard: null
                };
            });
        };

        const endPhase = () => {
            const phase = gameStateRef.current.phase;
            const player = (phase === 'redDeploy' || phase === 'redSupport') ? 'red' : 'blue';
            if (player !== gameManagerRef.current.playerSide) return;

            gameManagerRef.current.sendMessage({ type: 'end-phase' });
            doEndPhase();
        };

        const handleRemoteEndPhase = () => {
            doEndPhase();
        };

        const doEndPhase = () => {
            const phase = gameStateRef.current.phase;
            const next = {
                redDeploy: 'blueDeploy',
                blueDeploy: 'redSupport',
                redSupport: 'battle'
            };
            const target = next[phase];

            if (target === 'battle') {
                setGameState(prev => ({
                    ...prev,
                    phase: 'battle',
                    selectedCard: null,
                    log: [...prev.log, '--- æˆ˜æ–—é˜¶æ®µ ---']
                }));
                setTimeout(resolveBattle, 500);
            } else {
                const names = {
                    blueDeploy: 'è“æ–¹éƒ¨ç½²é˜¶æ®µ',
                    redSupport: 'çº¢æ–¹æ”¯æ´é˜¶æ®µ'
                };
                setGameState(prev => ({
                    ...prev,
                    phase: target,
                    selectedCard: null,
                    log: [...prev.log, `--- ${names[target]} ---`]
                }));
            }
        };

        const resolveBattle = async () => {
            const state = gameStateRef.current;
            let redBF = state.red.battlefield.map(c => c ? {...c} : null);
            let blueBF = state.blue.battlefield.map(c => c ? {...c} : null);
            let redHP = state.red.health;
            let blueHP = state.blue.health;
            let discard = [...state.discardPile];
            let logs = [];

            for (let i = 0; i < 4; i++) {
                setBattleAnimation({ active: true, lane: i });
                window.SoundManager.playSound('attack');
                await new Promise(r => setTimeout(r, 1000));

                const rc = redBF[i];
                const bc = blueBF[i];

                if (rc && bc) {
                    rc.hp -= bc.atk;
                    bc.hp -= rc.atk;
                    logs.push(`è·¯çº¿${i+1}: ${rc.name}(${rc.hp}HP) VS ${bc.name}(${bc.hp}HP)`);
                    
                    if (rc.hp <= 0) {
                        discard.push(rc);
                        redBF[i] = null;
                        logs.push(`  çº¢æ–¹ ${rc.name} è¢«å‡»è´¥`);
                    }
                    if (bc.hp <= 0) {
                        discard.push(bc);
                        blueBF[i] = null;
                        logs.push(`  è“æ–¹ ${bc.name} è¢«å‡»è´¥`);
                    }
                } else if (rc) {
                    blueHP -= rc.atk;
                    logs.push(`è·¯çº¿${i+1}: ${rc.name} æ”»å‡»è“æ–¹ï¼Œé€ æˆ ${rc.atk} ä¼¤å®³`);
                } else if (bc) {
                    redHP -= bc.atk;
                    logs.push(`è·¯çº¿${i+1}: ${bc.name} æ”»å‡»çº¢æ–¹ï¼Œé€ æˆ ${bc.atk} ä¼¤å®³`);
                }
            }

            setBattleAnimation({ active: false, lane: -1 });

            let newMDeck = [...state.miracleDeck];
            let redHand = [...state.red.hand];
            let blueHand = [...state.blue.hand];
            let redDrawn = [...state.red.miracleDrawn];
            let blueDrawn = [...state.blue.miracleDrawn];

            const milestones = [25, 20, 15, 10, 5];
            const drawMiracle = (hp, drawn, hand) => {
                const hit = milestones.some(m => hp <= m && !drawn.includes(m));
                if (hit) {
                    const newDrawn = [...drawn, ...milestones.filter(m => hp <= m && !drawn.includes(m))];
                    const card = newMDeck.pop();
                    if (card) {
                        hand.push(card);
                        return { drawn: newDrawn, drewName: card.name };
                    }
                    return { drawn: newDrawn, drewName: null };
                }
                return { drawn, drewName: null };
            };

            if (redHP < state.red.health) {
                const res = drawMiracle(redHP, redDrawn, redHand);
                redDrawn = res.drawn;
                if (res.drewName) logs.push(`çº¢æ–¹è¡€é‡é™è‡³ ${redHP}ï¼ŒæŠ½å–å¥‡è¿¹ç‰Œï¼š${res.drewName}`);
            }
            if (blueHP < state.blue.health) {
                const res = drawMiracle(blueHP, blueDrawn, blueHand);
                blueDrawn = res.drawn;
                if (res.drewName) logs.push(`è“æ–¹è¡€é‡é™è‡³ ${blueHP}ï¼ŒæŠ½å–å¥‡è¿¹ç‰Œï¼š${res.drewName}`);
            }

            if (redHP <= 0 || blueHP <= 0) {
                const w = redHP > blueHP ? 'çº¢æ–¹' : (blueHP > redHP ? 'è“æ–¹' : 'å¹³å±€');
                logs.push(`ğŸ‰ ${w === 'å¹³å±€' ? 'å¹³å±€' : w + 'è·èƒœï¼'}`);
                window.SoundManager.playSound('victory');
                setWinner(w);
            } else {
                logs.push('æˆ˜æ–—ç»“ç®—å®Œæˆ');
            }

            setGameState(prev => ({
                ...prev,
                phase: 'idle',
                red: {
                    ...prev.red,
                    battlefield: redBF,
                    health: redHP,
                    hand: redHand,
                    miracleDrawn: redDrawn
                },
                blue: {
                    ...prev.blue,
                    battlefield: blueBF,
                    health: blueHP,
                    hand: blueHand,
                    miracleDrawn: blueDrawn
                },
                miracleDeck: newMDeck,
                discardPile: discard,
                log: [...prev.log, ...logs]
            }));

            setTimeout(() => {
                const currentState = gameStateRef.current;
                if (currentState.deck.length === 0 && currentState.red.hand.length === 0 && currentState.blue.hand.length === 0 && !winner) {
                    const w = currentState.red.health > currentState.blue.health ? 'çº¢æ–¹' : (currentState.blue.health > currentState.red.health ? 'è“æ–¹' : 'å¹³å±€');
                    setWinner(w);
                    window.SoundManager.playSound('victory');
                    setGameState(prev => ({
                        ...prev,
                        log: [...prev.log, 'ç‰Œåº“è€—å°½', `${w === 'å¹³å±€' ? 'å¹³å±€' : w + 'è·èƒœ'}`]
                    }));
                }
            }, 100);
        };

        const reset = () => {
            setWinner(null);
            setGamePhase('notStarted');
            setBattleAnimation({ active: false, lane: -1 });
            setGameState(INIT_STATE);
            setScreen('lobby');
        };

        if (!uiReady) {
            return <div className="text-white text-center mt-40 text-xl">åŠ è½½ä¸­â€¦</div>;
        }

        if (showReconnectPrompt) {
            return (
                <div className="min-h-screen bg-gradient-to-br from-slate-900 via-purple-900 to-blue-900 flex items-center justify-center p-4">
                    <div className="max-w-md w-full bg-gray-800 rounded-2xl p-8 shadow-2xl border-2 border-yellow-500">
                        <div className="text-center mb-6">
                            <div className="text-6xl mb-4">ğŸ”„</div>
                            <h2 className="text-3xl font-bold text-white mb-2">æ£€æµ‹åˆ°æ–­çº¿</h2>
                            <p className="text-gray-300">å‘ç°æœªå®Œæˆçš„æ¸¸æˆ</p>
                        </div>

                        <div className="bg-gray-700 rounded-xl p-4 mb-6">
                            <div className="text-sm text-gray-300 mb-2">æˆ¿é—´å·</div>
                            <div className="text-2xl font-bold text-yellow-400 font-mono tracking-wider">
                                {reconnectData?.roomId}
                            </div>
                            <div className="text-sm text-gray-400 mt-2">
                                èº«ä»½: {reconnectData?.playerSide === 'red' ? 'çº¢æ–¹ğŸ”´' : 'è“æ–¹ğŸ”µ'}
                            </div>
                        </div>

                        <div className="grid gap-3">
                            <button
                                onClick={handleReconnect}
                                className="w-full py-4 bg-green-600 hover:bg-green-700 text-white rounded-xl font-bold text-lg transition-all duration-200"
                            >
                                é‡æ–°è¿æ¥
                            </button>
                            <button
                                onClick={handleNewGame}
                                className="w-full py-4 bg-gray-600 hover:bg-gray-700 text-white rounded-xl font-bold text-lg transition-all duration-200"
                            >
                                å¼€å§‹æ–°æ¸¸æˆ
                            </button>
                        </div>

                        <div className="mt-4 text-center text-xs text-gray-500">
                            é‡è¿åå°†æ¢å¤æ¸¸æˆè¿›åº¦
                        </div>
                    </div>
                </div>
            );
        }

        if (screen === 'menu') {
            return (
                <div className="min-h-screen bg-gradient-to-br from-slate-900 via-blue-900 to-purple-900 flex items-center justify-center p-4">
                    <div className="max-w-2xl w-full">
                        <div className="text-center mb-12">
                            <h1 className="text-6xl font-bold text-white mb-4 drop-shadow-lg">
                                ğŸŒ åœ¨çº¿å¯¹æˆ˜
                            </h1>
                            <p className="text-xl text-gray-300">é€šè¿‡æˆ¿é—´å·ä¸å¥½å‹å¯¹æˆ˜</p>
                        </div>

                        <div className="grid gap-6 mb-8">
                            <button
                                onClick={handleCreateRoom}
                                onMouseEnter={() => window.SoundManager.playSound('hover')}
                                className="group relative overflow-hidden rounded-2xl bg-gradient-to-br from-green-600 to-teal-600 p-8 text-left transform transition-all duration-300 hover:scale-105 hover:shadow-2xl"
                            >
                                <div className="relative z-10">
                                    <div className="text-6xl mb-4">ğŸ </div>
                                    <h2 className="text-3xl font-bold text-white mb-2">åˆ›å»ºæˆ¿é—´</h2>
                                    <p className="text-gray-200">åˆ›å»ºæ–°æˆ¿é—´ï¼Œé‚€è¯·å¥½å‹åŠ å…¥</p>
                                </div>
                            </button>

                            <div className="bg-gradient-to-br from-blue-600 to-purple-600 rounded-2xl p-8">
                                <div className="text-6xl mb-4">ğŸšª</div>
                                <h2 className="text-3xl font-bold text-white mb-4">åŠ å…¥æˆ¿é—´</h2>
                                <div className="flex gap-3">
                                    <input
                                        type="text"
                                        value={roomInput}
                                        onChange={(e) => setRoomInput(e.target.value.toUpperCase())}
                                        placeholder="è¾“å…¥6ä½æˆ¿é—´å·"
                                        maxLength={6}
                                        className="flex-1 px-4 py-3 rounded-lg text-xl font-bold text-center uppercase tracking-wider"
                                        onKeyPress={(e) => e.key === 'Enter' && handleJoinRoom()}
                                    />
                                    <button
                                        onClick={handleJoinRoom}
                                        className="px-6 py-3 bg-white hover:bg-gray-100 text-blue-600 rounded-lg font-bold text-xl transition-all duration-200"
                                    >
                                        åŠ å…¥
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div className="text-center">
                            <button
                                onClick={() => { window.SoundManager.playSound('click'); window.location.href = 'index.html'; }}
                                className="px-8 py-4 bg-gray-700 hover:bg-gray-600 text-white rounded-xl font-bold text-xl transition-all duration-200"
                            >
                                è¿”å›ä¸»ç•Œé¢
                            </button>
                        </div>

                        <div className="mt-8 text-center text-gray-400 text-sm">
                            <p>ğŸ’¡ åˆ›å»ºæˆ¿é—´åï¼Œå°†æˆ¿é—´å·åˆ†äº«ç»™å¥½å‹å³å¯å¼€å§‹å¯¹æˆ˜</p>
                            <p className="mt-2">ğŸ”„ æ”¯æŒæ–­çº¿é‡è¿ï¼Œåˆ·æ–°é¡µé¢ä¸ä¼šä¸¢å¤±è¿›åº¦</p>
                        </div>
                    </div>
                </div>
            );
        }

        if (screen === 'lobby') {
            return (
                <div className="min-h-screen bg-gradient-to-br from-slate-900 via-blue-900 to-purple-900 flex items-center justify-center p-4">
                    <div className="max-w-2xl w-full">
                        <div className="bg-gray-800 rounded-2xl p-8 shadow-2xl">
                            <div className="text-center mb-8">
                                <h2 className="text-4xl font-bold text-white mb-2">
                                    {gameManagerRef.current?.isHost ? 'ğŸ  æˆ¿é—´å·²åˆ›å»º' : 'ğŸšª å·²åŠ å…¥æˆ¿é—´'}
                                </h2>
                                <div className="text-6xl font-bold text-yellow-400 my-6 tracking-widest">
                                    {roomId}
                                </div>
                                <p className="text-gray-300 text-lg">
                                    {gameManagerRef.current?.isHost ? 'å°†æˆ¿é—´å·åˆ†äº«ç»™å¥½å‹' : 'ç­‰å¾…æˆ¿ä¸»å¼€å§‹æ¸¸æˆ'}
                                </p>
                            </div>

                            <div className="grid grid-cols-2 gap-4 mb-8">
                                <div className="bg-red-900/30 border-2 border-red-500 rounded-xl p-6 text-center">
                                    <div className="text-2xl mb-2">ğŸ”´</div>
                                    <div className="text-white font-bold mb-1">çº¢æ–¹ (æˆ¿ä¸»)</div>
                                    <div className={`text-sm ${gameManagerRef.current?.isHost ? 'text-green-400' : (opponentConnected ? 'text-green-400' : 'text-yellow-400')}`}>
                                        {gameManagerRef.current?.isHost ? 'ä½ ' : (opponentConnected ? 'å¯¹æ‰‹å·²è¿æ¥' : 'ç­‰å¾…ä¸­...')}
                                    </div>
                                </div>
                                <div className="bg-blue-900/30 border-2 border-blue-500 rounded-xl p-6 text-center">
                                    <div className="text-2xl mb-2">ğŸ”µ</div>
                                    <div className="text-white font-bold mb-1">è“æ–¹ (åŠ å…¥è€…)</div>
                                    <div className={`text-sm ${!gameManagerRef.current?.isHost ? 'text-green-400' : (opponentConnected ? 'text-green-400' : 'text-yellow-400')}`}>
                                        {!gameManagerRef.current?.isHost ? 'ä½ ' : (opponentConnected ? 'å¯¹æ‰‹å·²è¿æ¥' : 'ç­‰å¾…ä¸­...')}
                                    </div>
                                </div>
                            </div>

                            <div className="flex gap-4">
                                {gameManagerRef.current?.isHost && (
                                    <button
                                        onClick={handleStartGame}
                                        disabled={!opponentConnected}
                                        className={`flex-1 py-4 rounded-xl font-bold text-xl transition-all duration-200 ${
                                            opponentConnected
                                                ? 'bg-green-600 hover:bg-green-700 text-white'
                                                : 'bg-gray-600 text-gray-400 cursor-not-allowed'
                                        }`}
                                    >
                                        {opponentConnected ? 'å¼€å§‹æ¸¸æˆ' : 'ç­‰å¾…å¯¹æ‰‹...'}
                                    </button>
                                )}
                                {!gameManagerRef.current?.isHost && (
                                    <div className="flex-1 py-4 rounded-xl font-bold text-xl text-center bg-gray-700 text-gray-300">
                                        ç­‰å¾…æˆ¿ä¸»å¼€å§‹æ¸¸æˆ...
                                    </div>
                                )}
                                <button
                                    onClick={handleBackToLobby}
                                    className="px-8 py-4 bg-red-600 hover:bg-red-700 text-white rounded-xl font-bold text-xl transition-all duration-200"
                                >
                                    é€€å‡º
                                </button>
                            </div>

                            <div className="mt-6 text-center">
                                <div className="inline-flex items-center gap-2 px-4 py-2 bg-gray-700 rounded-lg">
                                    <div className={`w-3 h-3 rounded-full ${opponentConnected ? 'bg-green-500 animate-pulse' : 'bg-gray-500'}`}></div>
                                    <span className="text-gray-300 text-sm">
                                        {opponentConnected ? 'å¯¹æ‰‹åœ¨çº¿' : 'ç­‰å¾…å¯¹æ‰‹è¿æ¥...'}
                                    </span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        if (screen === 'game') {
            if (!window.GameUI) {
                return <div className="text-white text-center mt-40 text-xl">æ¸¸æˆUIæœªåŠ è½½â€¦</div>;
            }
            
            return (
                <window.GameUI
                    gameState={gameState}
                    gamePhase={gamePhase}
                    allCards={allCards}
                    winner={winner}
                    battleAnimation={battleAnimation}
                    cardShowOverlay={cardShowOverlay}
                    onStartPicking={() => {}}
                    onPickCard={pickCard}
                    onStartTurn={startTurn}
                    onSelectCard={selectCard}
                    onPlayCard={playCard}
                    onUseCardOnTarget={useCardOnTarget}
                    onConfirmUse={confirmUse}
                    onEndPhase={endPhase}
                    onReset={reset}
                    hideOpponentHand={true}
                    myRole={gameManagerRef.current?.playerSide}
                    extraUI={
                        <div className="fixed top-4 right-4 z-50 bg-gray-800 rounded-lg p-3 shadow-lg border-2 border-purple-500">
                            <div className="text-white text-sm">
                                <div className="font-bold mb-1">ğŸŒ åœ¨çº¿å¯¹æˆ˜</div>
                                <div className="text-yellow-400 font-mono">æˆ¿é—´: {roomId}</div>
                                <div className={`text-xs mt-1 flex items-center gap-1 ${opponentConnected ? 'text-green-400' : 'text-red-400'}`}>
                                    <div className={`w-2 h-2 rounded-full ${opponentConnected ? 'bg-green-500 animate-pulse' : 'bg-red-500'}`}></div>
                                    {opponentConnected ? 'å¯¹æ‰‹åœ¨çº¿' : 'å¯¹æ‰‹ç¦»çº¿'}
                                </div>
                            </div>
                        </div>
                    }
                />
            );
        }

        return null;
    };

    ReactDOM.render(<OnlineGame />, document.getElementById('root'));
    </script>
</body>
</html>
